## 适配器一、
适配器继承适配者实现新接口，调用适配者，完成自己的工作。

适配器二、

调用者创建适配者对象和适配器对象，塞入到适配器中

![](https://cdn.nlark.com/yuque/0/2023/png/39031477/1702373005767-24f352c9-fe18-4d40-806a-0846ac84691d.png)

## 代理模式
代理类和真实主题都继承抽象主题，调用代理类中的方法，在其中调用真实主题的方法

![](https://cdn.nlark.com/yuque/0/2023/png/39031477/1702373039749-c03d6e5b-eeba-47e2-9dc9-b333f4f17121.png)

## 装饰器模式
让对象传递给装饰器类，在装饰器类中调用，同时完成装饰器自己的功能。

缺点:污染了装饰器对象

![](https://cdn.nlark.com/yuque/0/2023/png/39031477/1702447784090-263a7ae2-15d5-4d3b-9302-c61edb8867d4.png)

锤子是主体

1、装饰器是锤子的超集，里面可以塞入锤子对象并加工共性的东西，出的还是锤子对象，但

2、木匠和铁匠都继承自装饰器类，调用一下父类装饰器中的函数

3、木匠加工时把锤子对象扔进去，铁匠加工时把锤子扔进去，共性会一起加工

## 建造者模式
使用内部类，和外部类结构完全一样，通过内部类接收参数，并通过返回this来实现链式调用，在builde方法中创建外部类对象

![](https://cdn.nlark.com/yuque/0/2023/png/39031477/1702453372008-ed3bdf25-6bb6-46a9-87f5-e74d48a1f42b.png)

## 桥接模式
<font style="color:rgb(77, 77, 77);">当一个类内部具备两种或多种变化维度时，使用桥接模式可以解耦这些变化的维度。比如包的款式、包的颜色。</font><font style="color:rgb(0, 0, 0);background-color:rgb(210, 249, 209);">桥接模式类似于就是手动封装的多继承？</font>

![](https://cdn.nlark.com/yuque/0/2023/png/39031477/1702456638016-28f3fd61-567d-4a3a-aee2-25ecb071a92d.png)

**方式二**：把一个维度当做另一个维度的属性

![](https://cdn.nlark.com/yuque/0/2023/png/39031477/1702457018684-72d0a3a7-ff03-4177-ae9c-b7f19b815785.png)



## 组合模式
1. <font style="color:rgb(25, 27, 31);">如树形菜单、文件、文件夹管理</font>
2. <font style="color:rgb(25, 27, 31);">从一个整体中独立出部分模块或功能的场景</font>

[组合模式（Composite Pattern）-CSDN博客](https://blog.csdn.net/qq_53868937/article/details/130669738)

![](https://cdn.nlark.com/yuque/0/2023/png/39031477/1702517342009-36fbde45-ec74-48c1-ae56-bebf5eced34e.png)







