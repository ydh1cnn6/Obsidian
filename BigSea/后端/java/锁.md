---
title: 锁
tags:
  - 笔记
  - 锁
author: BigSea
email: 2834637197@qq.com
封面: ""
createDate: 2025-06-11 09:16:11
updateDate: 2025-12-01 16:22:10
week: 第49周｜星期一
Country: China
City: NanJing
Weather: ☀️
uvIndex(1-15): 3
Temperature(℃): 16
CurrentWeatherTime: 12:00 AM
GetWeatherTime: 2025-12-01 14:44:42
Feels Like(℃): 16
Pressure(hPa): 1020
Humidity(%): 43
WindSpeed: 3
WindSpeedDesc: 微风
TempRange(℃): 10-18
SunHour: 10.5h
Sunrise: 06:47 AM
Sunset: 05:00 PM
---
### 1、偏向锁
> 偏向锁使用了一种等到竞争出现才释放锁的机制。一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测

### 2、轻量级锁
> 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
>

![画板](https://cdn.nlark.com/yuque/0/2025/jpeg/39031477/1747807835892-da811478-355e-4a62-8dbb-2d73c78c005c.jpeg)

### 原子操作
#### 总线锁：
使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

#### 缓存锁：
指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效

#### 不会使用缓存锁定场景：
第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。

第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。





### 互斥锁和自旋锁
| **特性** | **自旋锁** | **互斥锁** |
| :---: | :---: | :---: |
| **等待方式** | 忙等待（不释放CPU） | 阻塞（释放CPU，触发调度） |
| **适用锁时间** | 极短（纳秒级） | 较长（微秒级及以上） |
| **上下文切换** | 无 | 有（用户态↔内核态切换） |
| **典型应用** | 内核中断处理、高频计数器 | 用户态长任务、数据库事务 |


### run和start区别
run是runable的普通方法

start用来创建线程的

### CountDownLatch
1、latch.countDown();	latch减1

2、latch.await();	等到latch减到0，继续后续代码

[CountDownLatchTest.java案例](https://gitee.com/clearpp/multiDatabase/blob/master/learn/src/main/java/com/example/learn/thread/CountDownLatchTest.java)

### Daemon
Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出

> Java虚拟机退出时Daemon线程中的finally块并不一定会执行。main线程（非Daemon线程）在启动了线程DaemonRunner之后随着main方法执行完毕而终止，而此时Java虚拟机中已经没有非Daemon线程，虚拟机需要退出。Java虚拟机中的所有Daemon线程都需要立即终止，因此DaemonRunner立即终止，但是DaemonRunner中的finally块并没有执行。
>

#### finally不执行情况：
1. 程序终止或 JVM 崩溃
2. 守护线程中的finally
3. 系统崩溃

### isInterrupted()
1. 主动打断的是true
2. 睡眠等终结状态，哪怕打断也是false



### 睡眠方式
1. Thread.sleep(5000);		需要try..catch
2. TimeUnit.SECONDS.sleep(5);	需要try..catch
3. ThreadUtil.sleep(5, TimeUnit.SECONDS);	hutool工具包
4. 手动释放
    1. `**Object.wait/notify**`**	**
    2. `**Condition.await/signal**`
    3. `**LockSupport.park/unpark**`

> `wait`和`Condition.await`会释放锁



