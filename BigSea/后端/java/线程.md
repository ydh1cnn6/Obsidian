---
title: 线程
tags:
  - 笔记
  - 线程
author: BigSea
email: 2834637197@qq.com
封面: ""
createDate: 2025-11-14 13:27:08
updateDate: 2025-11-28 14:54:17
week: 第48周｜星期五
Country: China
City: NanJing
Weather: ☀️
uvIndex(1-15): 1
Temperature(℃): 9
CurrentWeatherTime: 09:00 AM
GetWeatherTime: 2025-11-28 10:49:55
Feels Like(℃): 7
Pressure(hPa): 1022
Humidity(%): 36
WindSpeed: 2
WindSpeedDesc: 轻风
TempRange(℃): 5-17
SunHour: 10.6h
Sunrise: 06:45 AM
Sunset: 05:00 PM
---
# 线程池
线程池中核心线程数没有满就会先创建一个新的核心线程这时候不会放入阻塞队列，当核心线程满了才是生产者把任务给阻塞队列，工作线程从阻塞队列获取任务，任务全部结束，工作线程进入park等待状态，一旦生产者提交新任务去阻塞队列，那么工作线程又会变成unpark状态重新开始新工作


# 线程的创建方式
## 继承`Thread`类
```java
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + i);
            try {
                Thread.sleep(500); // 线程休眠500ms
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class ThreadDemo {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();
        thread1.setName("线程A");
        thread2.setName("线程B");
        
        thread1.start(); // 启动线程（底层调用run()）
        thread2.start();
    }
}
```
## 实现`Runnable`接口
```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class RunnableDemo {
    public static void main(String[] args) {
        MyRunnable runnable = new MyRunnable();
        Thread thread1 = new Thread(runnable, "线程A");
        Thread thread2 = new Thread(runnable, "线程B");
        
        thread1.start();
        thread2.start();
    }
}
```

## 实现`Callable`接口（带返回值）
```java
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            sum += i;
            Thread.sleep(10);
        }
        return sum;
    }
}

public class CallableDemo {
    public static void main(String[] args) throws Exception {
        MyCallable callable = new MyCallable();
        FutureTask<Integer> futureTask = new FutureTask<>(callable);
        Thread thread = new Thread(futureTask, "求和线程");
        
        thread.start();
        System.out.println("线程执行中...");
        Integer result = futureTask.get(); // 阻塞等待结果返回
        System.out.println("1-100求和结果：" + result);
    }
}
```


# 线程的生命周期
Java 线程有**5 种状态**（JDK 官方定义），状态间通过方法切换：
## 1. 状态枚举（`Thread.State`）

- **NEW**（新建）：线程对象已创建，但未调用`start()`。
- **RUNNABLE**（就绪 / 运行）：调用`start()`后，线程进入就绪队列；获取 CPU 时间片后进入运行状态。
- **BLOCKED**（阻塞）：线程因竞争锁失败（如`synchronized`）而阻塞。
- **WAITING**（等待）：线程因调用`wait()`/`join()`/`LockSupport.park()`进入无限期等待，需其他线程唤醒。
- **TIMED_WAITING**（超时等待）：线程因调用`sleep(long)`/`wait(long)`/`join(long)`进入有限期等待，超时自动唤醒。
- **TERMINATED**（终止）：线程执行完毕或异常终止。

# 线程同步（解决线程安全问题）
## `synchronized`关键字
```java
class Counter {
    private int count = 0;
    
    // 同步实例方法（锁为Counter对象）
    public synchronized void increment() {
        count++;
    }
    
    // 同步代码块（锁为this）
    public void decrement() {
        synchronized (this) {
            count--;
        }
    }
    
    public int getCount() {
        return count;
    }
}

public class SynchronizedDemo {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                counter.increment();
            }
        });
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                counter.decrement();
            }
        });
        
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println("最终计数：" + counter.getCount()); // 预期0
    }
}
```

## `Lock`接口（显式锁）
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class LockCounter {
    private int count = 0;
    private Lock lock = new ReentrantLock(); // 默认非公平锁
    
    public void increment() {
        lock.lock(); // 获取锁
        try {
            count++;
        } finally {
            lock.unlock(); // 释放锁（必须在finally中）
        }
    }
    
    public int getCount() {
        return count;
    }
}

public class LockDemo {
    public static void main(String[] args) throws InterruptedException {
        LockCounter counter = new LockCounter();
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                counter.increment();
            }
        });
        t1.start();
        t1.join();
        System.out.println("计数结果：" + counter.getCount()); // 10000
    }
}
```
## `volatile`关键字
```java
class VolatileDemo {
    private volatile boolean flag = false;
    
    public void setFlag(boolean flag) {
        this.flag = flag;
    }
    
    public void waitForFlag() {
        while (!flag) {
            // 空循环，等待flag变为true
        }
        System.out.println("flag已更新为true");
    }
    
    public static void main(String[] args) {
        VolatileDemo demo = new VolatileDemo();
        Thread t1 = new Thread(demo::waitForFlag);
        t1.start();
        
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        demo.setFlag(true); // 主线程修改flag，t1立即可见
    }
}
```
# 线程间通信
```java
class SharedResource {
    private int count = 0;
    private static final int MAX = 5; // 最大容量
    
    // 生产者：生产产品
    public synchronized void produce() throws InterruptedException {
        while (count >= MAX) {
            wait(); // 队列满，等待消费者消费
        }
        count++;
        System.out.println("生产者生产，当前数量：" + count);
        notifyAll(); // 唤醒消费者
    }
    
    // 消费者：消费产品
    public synchronized void consume() throws InterruptedException {
        while (count <= 0) {
            wait(); // 队列空，等待生产者生产
        }
        count--;
        System.out.println("消费者消费，当前数量：" + count);
        notifyAll(); // 唤醒生产者
    }
}

public class ProducerConsumer {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();
        
        // 生产者线程
        Thread producer = new Thread(() -> {
            while (true) {
                try {
                    resource.produce();
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        // 消费者线程
        Thread consumer = new Thread(() -> {
            while (true) {
                try {
                    resource.consume();
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        producer.start();
        consumer.start();
    }
}
```
# 线程池（Executor 框架）
## `ThreadPoolExecutor`参数详解
```java
public ThreadPoolExecutor(
    int corePoolSize,        // 核心线程数（常驻线程）
    int maximumPoolSize,     // 最大线程数（核心+非核心）
    long keepAliveTime,      // 非核心线程空闲超时时间
    TimeUnit unit,           // 超时时间单位
    BlockingQueue<Runnable> workQueue, // 任务队列（存放等待执行的任务）
    ThreadFactory threadFactory,       // 线程工厂（创建线程）
    RejectedExecutionHandler handler   // 拒绝策略（任务满时的处理方式）
)
```
## 自定义线程池
```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolDemo {
    public static void main(String[] args) {
        // 自定义线程池
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2,          // 核心线程数
            4,          // 最大线程数
            60L,        // 非核心线程超时1分钟
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2), // 任务队列容量2
            new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略
        );
        
        // 提交5个任务（核心2 + 队列2 + 非核心2 → 第5个任务触发拒绝策略，由主线程执行）
        for (int i = 1; i <= 5; i++) {
            int taskId = i;
            executor.submit(() -> {
                System.out.println("任务" + taskId + "由线程" + Thread.currentThread().getName() + "执行");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        
        executor.shutdown(); // 优雅关闭（等待任务执行完毕）
    }
}
```
