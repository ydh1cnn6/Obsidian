---
title: 文件路径安全处理
tags:
  - 笔记
  - 未命名
author: BigSea
email: 2834637197@qq.com
封面: ""
createDate: 2025-12-03 10:37:11
updateDate: 2025-12-03 10:48:44
week: 第49周｜星期三
Country: China
City: NanJing
Weather: ☀️
uvIndex(1-15): 1
Temperature(℃): 5
CurrentWeatherTime: 09:00 AM
GetWeatherTime: 2025-12-03 10:37:15
Feels Like(℃): 2
Pressure(hPa): 1034
Humidity(%): 44
WindSpeed: 3
WindSpeedDesc: 微风
TempRange(℃): 4-9
SunHour: 10.5h
Sunrise: 06:49 AM
Sunset: 05:00 PM
---
# 文件路径处理的核心安全风险

1. **路径遍历攻击**：用户通过输入`../`、`..\`、`/`或系统特殊路径（如`C:\Windows\`），试图访问应用授权目录外的文件（例如：`../../etc/passwd`）。
2. **路径拼接错误**：直接拼接用户输入的字符串构造路径，导致非法路径注入（如`userInput = "file.txt; rm -rf /"`）。
3. **符号链接（软链接）绕过**：通过符号链接指向授权目录外的敏感文件。
4. **跨平台路径分隔符问题**：Windows 用`\`、Linux 用`/`，混用可能导致路径解析异常。

# 用`Path`类规范化路径，消除冗余
```java
import java.nio.file.Path;
import java.nio.file.Paths;

public class PathNormalizeExample {
    public static void main(String[] args) {
        // 原始路径包含../，存在遍历风险
        String userInput = "../secret/file.txt";
        Path rawPath = Paths.get(userInput);
        Path normalizedPath = rawPath.normalize(); // 结果：../secret/file.txt（仍需结合根目录校验）
        
        // 结合根目录解析（关键！）
        Path rootDir = Paths.get("/app/upload/"); // 应用允许的根目录
        Path resolvedPath = rootDir.resolve(normalizedPath).normalize();
        System.out.println(resolvedPath); // /app/secret/file.txt（仍跳出根目录，需进一步检查）
    }
}
```
# 限制路径在根目录内（沙箱化核心）
```java
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class PathSandboxExample {
    // 检查路径是否在根目录内
    public static Path getSafePath(String userInput, String rootDir) throws Exception {
        Path root = Paths.get(rootDir).toRealPath(); // 解析根目录的真实路径（消除符号链接）
        Path inputPath = Paths.get(userInput).normalize();
        
        // 解析为绝对路径并规范化
        Path resolvedPath = root.resolve(inputPath).toRealPath();
        
        // 检查是否以根目录为前缀（防止跳出沙箱）
        if (!resolvedPath.startsWith(root)) {
            throw new SecurityException("非法路径：超出授权目录范围");
        }
        return resolvedPath;
    }

    public static void main(String[] args) throws Exception {
        String rootDir = "/app/upload/";
        String userInput = "../secret/file.txt"; // 恶意输入
        
        try {
            Path safePath = getSafePath(userInput, rootDir);
            System.out.println("安全路径：" + safePath);
        } catch (SecurityException e) {
            System.out.println("路径非法：" + e.getMessage()); // 触发异常，拦截非法访问
        }
    }
}
```
####  过滤非法字符，拒绝危险输入
```java
public class PathValidationExample {
    // 校验文件名是否合法（仅允许字母、数字、下划线、扩展名）
    public static boolean isValidFileName(String fileName) {
        // 正则：仅允许字母、数字、-、_、.，且不以.开头（避免隐藏文件）
        return fileName.matches("^[a-zA-Z0-9_-]+\\.[a-zA-Z0-9]{1,5}$") 
                && !fileName.contains("/") 
                && !fileName.contains("\\") 
                && !fileName.contains("..");
    }

    public static void main(String[] args) {
        String goodFileName = "photo_123.jpg";
        String badFileName = "../secret.txt";
        
        System.out.println(isValidFileName(goodFileName)); // true
        System.out.println(isValidFileName(badFileName)); // false
    }
}
```
#### 防范符号链接攻击
```java
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.LinkOption;

public class SymbolicLinkExample {
    public static void checkSymbolicLink(Path path) throws Exception {
        // 检查是否为符号链接
        if (Files.isSymbolicLink(path)) {
            throw new SecurityException("禁止访问符号链接");
        }
        
        // 读取文件时不跟随符号链接
        Path realPath = path.toRealPath(LinkOption.NOFOLLOW_LINKS);
        System.out.println("真实路径（不跟随符号链接）：" + realPath);
    }

    public static void main(String[] args) throws Exception {
        Path linkPath = Paths.get("/app/upload/link_to_secret"); // 假设是符号链接
        checkSymbolicLink(linkPath); // 触发异常，拦截符号链接
    }
}
```
#### 避免手动拼接路径，使用`Path.resolve()`
```java
// 错误：手动拼接路径，存在注入风险
String badPath = rootDir + "/" + userInput; 

// 正确：用resolve()安全解析
Path goodPath = Paths.get(rootDir).resolve(userInput).normalize();
```