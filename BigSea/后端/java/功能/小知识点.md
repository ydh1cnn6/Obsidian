---
title: 小知识点
tags: [笔记, 未命名, 卡片链接]
author: BigSea
email: 2834637197@qq.com
封面: ""
createDate: 2025-12-04 09:40:44
updateDate: 2025-12-16 16:51:17
week: 第49周｜星期四
Country: China
City: NanJing
Weather: ☀️
uvIndex(1-15): 1
Temperature(℃): 5
CurrentWeatherTime: 09:00 AM
GetWeatherTime: 2025-12-04 09:40:48
Feels Like(℃): 3
Pressure(hPa): 1029
Humidity(%): 37
WindSpeed: 2
WindSpeedDesc: 轻风
TempRange(℃): 2-11
SunHour: 10.5h
Sunrise: 06:50 AM
Sunset: 05:00 PM
---
# 处理后立即覆写
“处理后立即覆写” 是指**对数据（如内存中的敏感信息、磁盘 / 文件中的临时数据）完成业务处理后，立刻用新数据（通常是无意义数据、空值或固定填充值）覆盖原数据所在的存储位置**，核心目的是**防止数据残留被非法恢复或窃取**，是数据安全领域的重要防护手段。

### 核心关键点

1. **及时性**：处理流程结束后不延迟，立刻执行覆写操作，避免数据长时间留存于存储介质；
2. **覆盖性**：用新数据完全覆盖原数据的存储单元（内存地址、磁盘扇区、文件块等），破坏原数据的可恢复性；
3. **安全性**：针对敏感数据（密码、密钥、个人信息、交易记录等）设计，防止通过内存 dump、磁盘恢复工具（如反删除软件）获取残留数据。

### 典型应用场景

#### 1. 内存中的敏感数据处理

程序运行时，密码、密钥等敏感信息会暂存于内存中。若仅 “删除引用”（如 Java 中置为`null`、C++ 中释放指针），内存中的原始数据仍可能残留，可通过内存扫描工具读取。**示例**：

- 处理完密码字符串后，用空字符`\0`覆盖字符数组的每个位置：
    
    java
    运行
    ```java
    char[] password = {'p','a','s','s','w','o','r','d'};
    // 处理密码（如验证身份）
    authenticate(password);
    // 立即覆写原密码数据
    Arrays.fill(password, '\0'); // 用空字符覆盖数组
    ```
#### 2. 磁盘 / 文件中的敏感数据
删除文件时，操作系统通常仅标记文件 “可覆盖”，原数据仍存于磁盘扇区，可通过数据恢复软件还原。“处理后立即覆写” 会直接改写这些扇区的数据。**示例**：
- 临时存储敏感信息的文件，使用后用随机字节覆写文件内容再删除：
    python
    运行
    ```python
    import os
    
    def secure_delete(file_path):
        if os.path.exists(file_path):
            # 获取文件大小，生成随机数据覆写
            file_size = os.path.getsize(file_path)
            with open(file_path, 'wb') as f:
                f.write(os.urandom(file_size))  # 用随机字节覆写
            os.remove(file_path)  # 删除文件
    ```
#### 3. 硬件 / 存储设备的销毁前处理
对报废的硬盘、U 盘等存储设备，会通过多次覆写（如 DoD 5220.22-M 标准要求 3 次覆写）彻底清除数据，防止物理拆解后恢复原数据。
### 为什么需要 “立即覆写”？
普通的 “删除” 操作（如清空变量、删除文件）并未真正清除数据，只是释放了数据的 “访问入口”。而 “处理后立即覆写” 从物理存储层面破坏原数据，确保敏感信息无法被逆向获取，是防范数据泄露的关键措施，广泛应用于金融、密码学、隐私保护等领域。



# ReDoS
ReDoS（Regular Expression Denial of Service，正则表达式拒绝服务）是一种针对正则表达式匹配引擎的攻击方式，通过构造**特殊恶意输入字符串**，触发正则表达式的**灾难性回溯**（Catastrophic Backtracking），导致匹配过程陷入指数级时间复杂度的计算，最终耗尽服务器 CPU、内存资源，造成服务响应超时、崩溃或拒绝服务。
### 一、ReDoS 的核心原理：灾难性回溯
正则表达式引擎在处理包含**重复量词（`*`/`+`/`?`/`{n,}`）** 和**嵌套 / 交替结构**的模式时，若输入字符串无法匹配但能触发大量回溯尝试，就会出现 “灾难性回溯”。
#### 举例：危险正则与恶意输入
假设有正则表达式用于验证 “以 b 结尾的 a 序列”：
regex
```regex
(a+)+b
```
- 正常输入（如`aaab`）：匹配成功，耗时极短；
- 恶意输入（如`aaaaaaaaaaaaaaaaaaaa`，无 b 结尾）：正则引擎会尝试所有可能的`a+`的组合拆分方式（比如将 n 个 a 拆分为 1+1+…+1、2+1+…+1、…、n），回溯次数随 a 的数量呈**指数级增长**（n 个 a 的回溯次数约为 2ⁿ）。
当输入的 a 达到 20 个时，回溯次数可能超过百万次；达到 30 个时，次数会突破十亿次，直接导致 CPU 满载。
### 二、常见的危险正则模式
ReDoS 通常源于正则表达式中**重复量词的嵌套 / 叠加**或**模糊的交替结构**，以下是典型危险模式：
1. **嵌套重复量词**
    - 示例：`(a+)*`、`(a|b)*+`、`(.*)+`
    - 风险：外层重复嵌套内层重复，输入无终止符时触发大量回溯。
2. **交替结构 + 重复量词**
    - 示例：`(a|aa)+`、`(ab|aab)+`
    - 风险：交替分支长度相近，引擎需尝试所有分支组合，输入越长耗时越久。
3. **贪婪与惰性量词混用**
    - 示例：`^.*(foo).*$`（匹配含 foo 的字符串，但`.*`贪婪匹配会先吞入所有字符再回溯）
    - 风险：若输入无 foo，`.*`会逐步回溯，输入越长回溯次数越多。
4. **无边界的重复匹配**
    - 示例：`\d+@\d+`（验证邮箱时错误使用数字匹配域名）
    - 风险：输入超长数字串（如`1234567890@1234567890...`）会触发低效匹配。
### 三、ReDoS 的风险场景
所有依赖正则表达式处理**用户可控输入**的场景都可能受攻击，常见场景包括：
- **输入验证**：手机号、邮箱、密码、URL 的正则校验（如用户注册时提交恶意输入）；
- **日志分析**：用正则解析用户行为日志、访问日志；
- **爬虫 / 数据清洗**：正则匹配 HTML 标签、URL 路径；
- **API 接口**：接口参数的正则校验（如过滤特殊字符）。
### 四、ReDoS 的防范措施
1. **避免危险正则结构**
    - 移除不必要的嵌套重复（如将`(a+)+b`简化为`a+b`）；
    - 明确匹配边界（如用`^a+b$`代替`(a+)+b`，避免部分匹配导致的回溯）；
    - 对可选分支做长度区分（如`(a|aaa)+`比`(a|aa)+`更安全，减少分支组合）。
2. **使用非回溯正则引擎**
    - 传统正则引擎（如 Java 的`java.util.regex`、Python 的`re`）基于回溯实现，易触发 ReDoS；
    - 改用**线性时间正则引擎**（如 Google 的 RE2、Rust 的`regex`库），这类引擎通过有限自动机实现，无回溯风险。
3. **限制输入长度**
    - 对用户输入设置长度上限（如密码最长 64 位、邮箱最长 128 位），即使正则低效，也能控制匹配时间。
4. **测试正则性能**
    - 用长输入、边缘输入测试正则的匹配耗时（如用`aaaaaaaaa...`测试`(a+)+b`）；
    - 使用工具检测危险正则（如`regexploit`、`safe-regex`）。
5. **优化正则写法**
    - 用具体字符集代替模糊匹配（如`[a-z]+`代替`.*`）；
    - 优先使用非捕获组`(?:...)`减少引擎开销；
    - 对固定后缀的匹配，先检查后缀再匹配前缀（如先判断输入是否以`b`结尾，再匹配`a+`）。



Java 中的`Queue`是`Collection`的子接口，用于模拟 “队列”（通常遵循 FIFO 先进先出规则），其方法可分为**两大核心组**（操作失败时 “抛异常” vs “返回特殊值”），还有扩展接口`Deque`（双端队列）的补充方法。以下是完整的方法梳理和说明：


# Queue
### 一、Queue 核心方法（分两类：抛异常 / 返回特殊值）
`Queue`的核心操作围绕 “新增元素、获取并移除队首、获取队首（不移除）” 展开，两类方法对应不同的异常处理策略，是最常用的基础方法：

| 操作类型      | 抛异常的方法             | 返回特殊值的方法             | 说明                                                                                       |
| --------- | ------------------ | -------------------- | ---------------------------------------------------------------------------------------- |
| 新增元素（入队）  | `boolean add(E e)` | `boolean offer(E e)` | 向队列尾部添加元素；<br>→ `add`：失败（如队列满）抛`IllegalStateException`；<br>→ `offer`：失败返回`false`（更安全，推荐） |
| 获取并移除队首   | `E remove()`       | `E poll()`           | 移除并返回队首元素；<br>→ `remove`：队列为空抛`NoSuchElementException`；<br>→ `poll`：队列为空返回`null`         |
| 获取队首（不移除） | `E element()`      | `E peek()`           | 返回队首元素（不移除）；<br>→ `element`：队列为空抛`NoSuchElementException`；<br>→ `peek`：队列为空返回`null`      |
#### 基础示例（LinkedList 实现 Queue）：
java
运行
```java
import java.util.LinkedList;
import java.util.Queue;

public class QueueDemo {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();

        // 1. 新增元素
        queue.add("A"); // 成功返回true
        boolean isAdded = queue.offer("B"); // 成功返回true
        System.out.println(queue); // [A, B]

        // 2. 获取并移除队首
        String first1 = queue.remove(); // 移除并返回"A"
        String first2 = queue.poll(); // 移除并返回"B"
        String nullPoll = queue.poll(); // 队列为空，返回null

        // 3. 获取队首（不移除）
        queue.offer("C");
        String first3 = queue.element(); // 返回"C"（不移除）
        String first4 = queue.peek(); // 返回"C"（不移除）
        queue.clear();
        String nullPeek = queue.peek(); // 队列为空，返回null
    }
}
```
### 二、Deque（双端队列）扩展方法（常用）
`Deque`是`Queue`的子接口（双端队列，支持首尾双向操作），常用实现如`LinkedList`、`ArrayDeque`，补充了针对 “队首 / 队尾” 的双向操作方法，同样分 “抛异常” 和 “返回特殊值” 两类：

| 操作类型      | 抛异常的方法               | 返回特殊值的方法                  | 说明                             |
| --------- | -------------------- | ------------------------- | ------------------------------ |
| 队首新增      | `void addFirst(E e)` | `boolean offerFirst(E e)` | 向队首添加元素                        |
| 队尾新增      | `void addLast(E e)`  | `boolean offerLast(E e)`  | 向队尾添加元素（同 Queue 的 add/offer）   |
| 队首移除      | `E removeFirst()`    | `E pollFirst()`           | 移除并返回队首（同 Queue 的 remove/poll） |
| 队尾移除      | `E removeLast()`     | `E pollLast()`            | 移除并返回队尾                        |
| 队首查看（不移除） | `E getFirst()`       | `E peekFirst()`           | 查看队首（同 Queue 的 element/peek）   |
| 队尾查看（不移除） | `E getLast()`        | `E peekLast()`            | 查看队尾                           |
#### Deque 示例（模拟栈 / 队列）：
java
运行
```java
import java.util.Deque;
import java.util.LinkedList;

public class DequeDemo {
    public static void main(String[] args) {
        Deque<String> deque = new LinkedList<>();

        // 队尾新增（同Queue）
        deque.offerLast("A");
        deque.offerLast("B");

        // 队首新增
        deque.offerFirst("0"); // 队列变为 [0, A, B]

        // 队尾移除
        String last = deque.pollLast(); // 返回"B"
        // 队首查看
        String first = deque.peekFirst(); // 返回"0"
    }
}
```
### 三、继承自 Collection 的通用方法
`Queue`继承了`Collection`的通用方法，日常也常使用：

| 方法                           | 说明                          |
| ---------------------------- | --------------------------- |
| `int size()`                 | 返回队列中元素的数量                  |
| `boolean isEmpty()`          | 判断队列是否为空（队列为空返回 true）       |
| `void clear()`               | 清空队列中所有元素                   |
| `boolean contains(Object o)` | 判断队列是否包含指定元素（返回 true/false） |
| `Iterator<E> iterator()`     | 返回迭代器，遍历队列元素（默认按 FIFO 顺序）   |
### 四、特殊场景方法（部分实现类特有）
1. **阻塞队列（BlockingQueue）**：`Queue`的子接口`BlockingQueue`（如`ArrayBlockingQueue`、`LinkedBlockingQueue`）补充了**阻塞方法**，适用于多线程场景：
    - `put(E e)`：队列满时阻塞，直到有空间；
    - `take()`：队列为空时阻塞，直到有元素；
    - `offer(E e, long timeout, TimeUnit unit)`：队列满时阻塞指定时间，超时返回 false；
    - `poll(long timeout, TimeUnit unit)`：队列为空时阻塞指定时间，超时返回 null。
2. **优先级队列（PriorityQueue）**：无额外特有方法，但`peek()`/`poll()`返回的是 “优先级最高” 的元素（而非 FIFO），需注意与普通队列的区别。
### 五、核心使用建议
1. 普通场景优先用`offer()`/`poll()`/`peek()`（返回特殊值），避免捕获异常，代码更简洁；
2. 多线程场景用`BlockingQueue`的阻塞方法（`put()`/`take()`），无需手动处理等待 / 唤醒；
3. 需双向操作（如栈、双端队列）时，用`Deque`（替代过时的`Stack`类）；
4. `PriorityQueue`不保证 FIFO，仅保证队首是优先级最高的元素，需注意排序规则（默认自然序，可自定义 Comparator）。

# 归并排序
归并排序（Merge Sort）是基于**分治（Divide and Conquer）** 思想的经典排序算法，核心是 “先拆分、后合并”—— 将数组递归拆分为更小的子数组，直到子数组长度为 1（天然有序），再将有序子数组合并为一个完整的有序数组。它的最大特点是**时间复杂度稳定（O (n log n)）**、**稳定排序**，但需要额外的空间存储临时数据。
### 一、核心原理
归并排序的核心是 “分” 和 “治” 两个阶段：
#### 1. 分（Divide）：递归拆分
将待排序数组从中间拆分为左、右两个子数组，递归对左、右子数组重复拆分，直到每个子数组仅含 1 个元素（长度为 1 的数组默认有序）。
#### 2. 治（Conquer）：合并有序子数组
将两个有序的子数组合并为一个有序数组（这是归并排序的核心步骤），最终合并所有子数组得到完整的有序数组。
### 二、排序步骤（以数组 `[3,1,4,1,5,9,2,6]` 为例）
1. **拆分阶段**：
    - 原数组：`[3,1,4,1,5,9,2,6]` → 拆分为 `[3,1,4,1]` 和 `[5,9,2,6]`；
    - 继续拆分：`[3,1,4,1]` → `[3,1]`、`[4,1]`；`[5,9,2,6]` → `[5,9]`、`[2,6]`；
    - 最终拆分：`[3]、[1]、[4]、[1]、[5]、[9]、[2]、[6]`（所有子数组长度为 1）。
2. **合并阶段**：
    - 合并 `[3]` 和 `[1]` → `[1,3]`；合并 `[4]` 和 `[1]` → `[1,4]`；
    - 合并 `[1,3]` 和 `[1,4]` → `[1,1,3,4]`；
    - 合并 `[5]` 和 `[9]` → `[5,9]`；合并 `[2]` 和 `[6]` → `[2,6]`；
    - 合并 `[5,9]` 和 `[2,6]` → `[2,5,6,9]`；
    - 最终合并 `[1,1,3,4]` 和 `[2,5,6,9]` → `[1,1,2,3,4,5,6,9]`。
### 三、Java 实现（递归版，最易理解）
递归版是归并排序的经典实现，核心是「递归拆分 + 合并方法」，临时数组全局创建以减少内存开销：
java
运行
```java
public class MergeSort {
    // 归并排序主方法：对外暴露的统一入口
    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return; // 空数组或单元素数组无需排序
        }
        int[] temp = new int[arr.length]; // 全局临时数组，避免频繁创建
        mergeSort(arr, 0, arr.length - 1, temp);
    }

    // 递归拆分：将[left, right]区间拆分为左右子数组，再合并
    private static void mergeSort(int[] arr, int left, int right, int[] temp) {
        if (left >= right) {
            return; // 子数组长度为1，终止递归
        }
        // 计算中间索引（避免 left+right 溢出）
        int mid = left + (right - left) / 2;
        // 递归拆分左子数组 [left, mid]
        mergeSort(arr, left, mid, temp);
        // 递归拆分右子数组 [mid+1, right]
        mergeSort(arr, mid + 1, right, temp);
        // 合并左右两个有序子数组
        merge(arr, left, mid, right, temp);
    }

    // 核心：合并 [left, mid] 和 [mid+1, right] 两个有序子数组
    private static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;     // 左子数组的起始指针
        int j = mid + 1;  // 右子数组的起始指针
        int k = left;     // 临时数组的起始指针（与左子数组对齐）

        // 步骤1：比较左右子数组，将较小的元素放入临时数组
        while (i <= mid && j <= right) {
            // 用 <= 保证相等元素的相对顺序，实现稳定排序
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }

        // 步骤2：拷贝左子数组剩余元素（若有）
        while (i <= mid) {
            temp[k++] = arr[i++];
        }

        // 步骤3：拷贝右子数组剩余元素（若有）
        while (j <= right) {
            temp[k++] = arr[j++];
        }

        // 步骤4：将临时数组的有序数据拷贝回原数组
        System.arraycopy(temp, left, arr, left, right - left + 1);
    }

    // 测试示例
    public static void main(String[] args) {
        int[] arr = {3, 1, 4, 1, 5, 9, 2, 6};
        System.out.println("排序前：");
        for (int num : arr) {
            System.out.print(num + " ");
        }

        mergeSort(arr);

        System.out.println("\n排序后：");
        for (int num : arr) {
            System.out.print(num + " "); // 输出：1 1 2 3 4 5 6 9
        }
    }
}
```
### 四、关键特性分析
|特性|说明|
|---|---|
|时间复杂度|最好 / 最坏 / 平均均为 `O(n log n)`：<br><br>- 拆分阶段：递归深度为 `log₂n`（如 n=8，拆 3 层）；<br><br>- 合并阶段：每层合并的总操作数为 `n`；<br><br>总复杂度 = 层数 × 每层操作数 = `n log n`。|
|空间复杂度|`O(n)`：主要开销是全局临时数组（占用 `n` 个空间）；递归栈的空间为 `O(log n)`（可忽略）。|
|稳定性|**稳定排序**：合并时通过 `arr[i] <= arr[j]` 保留相等元素的相对顺序（如示例中的两个 1）。|
|适用场景|1. 大规模数据排序（时间复杂度稳定，不受数据分布影响）；<br><br>2. 外部排序（数据在磁盘，无法一次性加载到内存，可分段合并）；<br><br>3. 对稳定性有要求的场景。|
|缺点|需额外的临时数组空间，小数据量时不如插入排序高效。|
### 五、补充：非递归版（避免递归栈溢出）
递归版在处理**超大规模数组**时可能触发栈溢出，非递归版通过迭代实现，从长度为 1 的子数组开始合并，逐步翻倍：
java
运行
```java
public static void mergeSortNonRecursive(int[] arr) {
    if (arr == null || arr.length <= 1) return;
    int n = arr.length;
    int[] temp = new int[n];
    // 子数组长度从1开始，每次翻倍（1→2→4→8...）
    for (int step = 1; step < n; step *= 2) {
        // 按step长度合并相邻子数组
        for (int left = 0; left < n; left += 2 * step) {
            int mid = Math.min(left + step - 1, n - 1); // 避免越界
            int right = Math.min(left + 2 * step - 1, n - 1);
            merge(arr, left, mid, right, temp); // 复用之前的merge方法
        }
    }
}
```
### 总结
归并排序是 “稳定且时间复杂度最优” 的排序算法，核心是**分治思想 + 有序合并**：
- 递归版易理解，适合日常开发和学习；
- 非递归版避免栈溢出，适合超大规模数据；
- 虽需额外空间，但在大规模、稳定性要求高的场景下是首选（如数据库排序、外部排序）。

# Collections方法
`sort(List<T> list)`**自然顺序**
`sort(List<T> list, Comparator<? super T> c)`按**自定义比较器**排序
`reverse(List<?> list)`反转 List 中元素的顺序
`shuffle(List<?> list)`随机打乱 List 元素（随机排序）
`swap(List<?> list, int i, int j)`交换 List 中两个索引位置的元素
`rotate(List<?> list, int distance)`旋转 List：distance 为正→右移，负→左移
`parallelSort(List<T> list)`JDK8+ 新增，并行排序（大 List 更高效）

# 后缀表达式
后缀表达式（又称 **逆波兰表达式，Reverse Polish Notation, RPN**）是一种**不依赖括号**的数学表达式表示法，核心特点是：**运算符位于其对应的操作数之后**，完全通过 “操作数顺序 + 运算符位置” 确定计算优先级，无需括号或运算符优先级规则（如先乘除后加减），非常适合计算机直接处理（编译器、计算器底层常用）。
### 一、核心对比：中缀表达式 vs 后缀表达式
我们日常使用的是**中缀表达式**（运算符在两个操作数中间），需要括号和优先级规则；后缀表达式通过调整顺序，消除了括号和优先级依赖，示例如下：

|表达式类型|示例（计算 3 + 4 × 2）|示例（计算 (3 + 4) × 2）|核心特点|
|---|---|---|---|
|中缀表达式|3 + 4 × 2|(3 + 4) × 2|运算符在中间，需括号 / 优先级|
|后缀表达式|3 4 2 × +|3 4 + 2 ×|运算符在后面，无括号 / 优先级|
#### 关键观察：
- 中缀的 `3 + 4 × 2`：乘法优先级高，后缀通过 “4 2 ×” 先计算乘法，再与 3 相加；
- 中缀的 `(3 + 4) × 2`：括号强制先加，后缀通过 “3 4 +” 先计算加法，再与 2 相乘；
- 后缀表达式的**顺序直接决定计算顺序**，计算机无需解析优先级和括号。
### 二、后缀表达式的计算方法（核心：栈）
计算机处理后缀表达式的核心是**栈（先进后出）**，步骤简单且固定，全程线性扫描一次即可完成：
1. **初始化一个空栈**；
2. **扫描后缀表达式的每个元素**：
    - 若元素是**操作数**（数字），直接压入栈；
    - 若元素是**运算符**，弹出栈顶的两个操作数（注意：先弹的是 “右操作数”，后弹的是 “左操作数”）；
    - 用运算符对两个操作数计算，将结果压入栈；
3. **扫描结束后**，栈中仅剩一个元素，即为表达式的结果。
#### 实战示例 1：计算后缀表达式 `3 4 2 × +`（对应中缀 3 + 4×2）
步骤拆解：

|扫描元素|栈状态（从底到顶）|操作说明|
|---|---|---|
|3|[3]|操作数，压栈|
|4|[3, 4]|操作数，压栈|
|2|[3, 4, 2]|操作数，压栈|
|×|[3, 8]|运算符：弹出 2 和 4，计算 4×2=8，压栈|
|+|[11]|运算符：弹出 8 和 3，计算 3+8=11，压栈|
|结束|[11]|栈顶为结果：11|
#### 实战示例 2：计算后缀表达式 `3 4 + 2 ×`（对应中缀 (3+4)×2）
步骤拆解：

|扫描元素|栈状态（从底到顶）|操作说明|
|---|---|---|
|3|[3]|操作数，压栈|
|4|[3, 4]|操作数，压栈|
|+|[7]|运算符：弹出 4 和 3，计算 3+4=7，压栈|
|2|[7, 2]|操作数，压栈|
|×|[14]|运算符：弹出 2 和 7，计算 7×2=14，压栈|
|结束|[14]|栈顶为结果：14|
### 三、中缀表达式转后缀表达式（手动 / 计算机通用方法）
若要将日常的中缀表达式转为后缀，核心仍是**栈**（存储运算符），配合输出队列（存储后缀结果），步骤如下：
1. **初始化**：空栈（存运算符）、空输出队列（存后缀结果）；
2. **扫描中缀表达式的每个元素**：
    - 若元素是**操作数**：直接加入输出队列；
    - 若元素是**左括号 `(`**：直接压入栈（括号优先级最高，需优先处理内部）；
    - 若元素是**右括号 `)`**：弹出栈顶运算符，加入输出队列，直到弹出左括号 `(`（左括号不加入队列，直接丢弃）；
    - 若元素是**运算符（+、-、×、/ 等）**：
        - 弹出栈顶所有 “优先级 ≥ 当前运算符” 的运算符，加入输出队列；
        - 将当前运算符压入栈；
3. **扫描结束后**：弹出栈中剩余所有运算符，加入输出队列；
4. **输出队列的元素顺序**，即为后缀表达式。
#### 优先级规则（默认）：
`(` > `×、/` > `+、-`（左括号优先级最高，乘除高于加减，同优先级从左到右）
#### 实战示例：中缀 `(3 + 4) × 2 - 5` 转后缀
步骤拆解：

|扫描元素|栈状态（顶→底）|输出队列|操作说明|
|---|---|---|---|
|(|[(]|[]|左括号，压栈|
|3|[(]|[3]|操作数，入队|
|+|[(, +]|[3]|运算符，栈顶是 (，直接压栈|
|4|[(, +]|[3, 4]|操作数，入队|
|)|[]|[3,4,+]|右括号，弹出 + 入队，再弹出 ( 丢弃|
|×|[×]|[3,4,+]|运算符，栈空，压栈|
|2|[×]|[3,4,+,2]|操作数，入队|
|-|[-]|[3,4,+,2,×]|运算符，栈顶 × 优先级高，弹出 × 入队，再压 -|
|5|[-]|[3,4,+,2,×,5]|操作数，入队|
|结束|[]|[3,4,+,2,×,5,-]|弹出剩余 - 入队|
最终后缀表达式：`3 4 + 2 × 5 -`（计算结果：14 - 5 = 9）
### 四、后缀表达式的核心优势
1. **无歧义**：消除了括号和运算符优先级，计算机无需复杂解析；
2. **高效计算**：线性扫描一次即可完成计算，时间复杂度 O (n)；
3. **实现简单**：仅需栈数据结构，编译器、计算器底层广泛应用；
4. **扩展性强**：支持自定义运算符（如幂运算、取模），只需扩展优先级规则。
### 五、应用场景
- 编译器 / 解释器：将源代码中的表达式（中缀）转为后缀表达式，再编译执行；
- 计算器应用：底层计算逻辑（如手机计算器、编程计算器）；
- 表达式求值引擎：如规则引擎、公式编辑器中的表达式解析。
### 总结
- 后缀表达式 = 操作数在前，运算符在后，无括号、无优先级依赖；
- 计算核心：栈（操作数压栈，运算符弹栈计算）；
- 转换核心：栈（存储运算符）+ 输出队列（存储结果），按优先级处理运算符；
- 核心价值：让计算机能简单、高效地处理数学表达式后缀表达式（又称 **逆波兰表达式，Reverse Polish Notation, RPN**）是一种**不依赖括号**的数学表达式表示法，核心特点是：**运算符位于其对应的操作数之后**，完全通过 “操作数顺序 + 运算符位置” 确定计算优先级，无需括号或运算符优先级规则（如先乘除后加减），非常适合计算机直接处理（编译器、计算器底层常用）。
### 一、核心对比：中缀表达式 vs 后缀表达式
我们日常使用的是**中缀表达式**（运算符在两个操作数中间），需要括号和优先级规则；后缀表达式通过调整顺序，消除了括号和优先级依赖，示例如下：

|表达式类型|示例（计算 3 + 4 × 2）|示例（计算 (3 + 4) × 2）|核心特点|
|---|---|---|---|
|中缀表达式|3 + 4 × 2|(3 + 4) × 2|运算符在中间，需括号 / 优先级|
|后缀表达式|3 4 2 × +|3 4 + 2 ×|运算符在后面，无括号 / 优先级|
#### 关键观察：
- 中缀的 `3 + 4 × 2`：乘法优先级高，后缀通过 “4 2 ×” 先计算乘法，再与 3 相加；
- 中缀的 `(3 + 4) × 2`：括号强制先加，后缀通过 “3 4 +” 先计算加法，再与 2 相乘；
- 后缀表达式的**顺序直接决定计算顺序**，计算机无需解析优先级和括号。
### 二、后缀表达式的计算方法（核心：栈）
计算机处理后缀表达式的核心是**栈（先进后出）**，步骤简单且固定，全程线性扫描一次即可完成：
1. **初始化一个空栈**；
2. **扫描后缀表达式的每个元素**：
    - 若元素是**操作数**（数字），直接压入栈；
    - 若元素是**运算符**，弹出栈顶的两个操作数（注意：先弹的是 “右操作数”，后弹的是 “左操作数”）；
    - 用运算符对两个操作数计算，将结果压入栈；
3. **扫描结束后**，栈中仅剩一个元素，即为表达式的结果。
#### 实战示例 1：计算后缀表达式 `3 4 2 × +`（对应中缀 3 + 4×2）
步骤拆解：

|扫描元素|栈状态（从底到顶）|操作说明|
|---|---|---|
|3|[3]|操作数，压栈|
|4|[3, 4]|操作数，压栈|
|2|[3, 4, 2]|操作数，压栈|
|×|[3, 8]|运算符：弹出 2 和 4，计算 4×2=8，压栈|
|+|[11]|运算符：弹出 8 和 3，计算 3+8=11，压栈|
|结束|[11]|栈顶为结果：11|
#### 实战示例 2：计算后缀表达式 `3 4 + 2 ×`（对应中缀 (3+4)×2）
步骤拆解：

|扫描元素|栈状态（从底到顶）|操作说明|
|---|---|---|
|3|[3]|操作数，压栈|
|4|[3, 4]|操作数，压栈|
|+|[7]|运算符：弹出 4 和 3，计算 3+4=7，压栈|
|2|[7, 2]|操作数，压栈|
|×|[14]|运算符：弹出 2 和 7，计算 7×2=14，压栈|
|结束|[14]|栈顶为结果：14|
### 三、中缀表达式转后缀表达式（手动 / 计算机通用方法）
若要将日常的中缀表达式转为后缀，核心仍是**栈**（存储运算符），配合输出队列（存储后缀结果），步骤如下：
1. **初始化**：空栈（存运算符）、空输出队列（存后缀结果）；
2. **扫描中缀表达式的每个元素**：
    - 若元素是**操作数**：直接加入输出队列；
    - 若元素是**左括号 `(`**：直接压入栈（括号优先级最高，需优先处理内部）；
    - 若元素是**右括号 `)`**：弹出栈顶运算符，加入输出队列，直到弹出左括号 `(`（左括号不加入队列，直接丢弃）；
    - 若元素是**运算符（+、-、×、/ 等）**：
        - 弹出栈顶所有 “优先级 ≥ 当前运算符” 的运算符，加入输出队列；
        - 将当前运算符压入栈；
3. **扫描结束后**：弹出栈中剩余所有运算符，加入输出队列；
4. **输出队列的元素顺序**，即为后缀表达式。
#### 优先级规则（默认）：
`(` > `×、/` > `+、-`（左括号优先级最高，乘除高于加减，同优先级从左到右）
#### 实战示例：中缀 `(3 + 4) × 2 - 5` 转后缀
步骤拆解：

|扫描元素|栈状态（顶→底）|输出队列|操作说明|
|---|---|---|---|
|(|[(]|[]|左括号，压栈|
|3|[(]|[3]|操作数，入队|
|+|[(, +]|[3]|运算符，栈顶是 (，直接压栈|
|4|[(, +]|[3, 4]|操作数，入队|
|)|[]|[3,4,+]|右括号，弹出 + 入队，再弹出 ( 丢弃|
|×|[×]|[3,4,+]|运算符，栈空，压栈|
|2|[×]|[3,4,+,2]|操作数，入队|
|-|[-]|[3,4,+,2,×]|运算符，栈顶 × 优先级高，弹出 × 入队，再压 -|
|5|[-]|[3,4,+,2,×,5]|操作数，入队|
|结束|[]|[3,4,+,2,×,5,-]|弹出剩余 - 入队|
最终后缀表达式：`3 4 + 2 × 5 -`（计算结果：14 - 5 = 9）
### 四、后缀表达式的核心优势
1. **无歧义**：消除了括号和运算符优先级，计算机无需复杂解析；
2. **高效计算**：线性扫描一次即可完成计算，时间复杂度 O (n)；
3. **实现简单**：仅需栈数据结构，编译器、计算器底层广泛应用；
4. **扩展性强**：支持自定义运算符（如幂运算、取模），只需扩展优先级规则。
### 五、应用场景
- 编译器 / 解释器：将源代码中的表达式（中缀）转为后缀表达式，再编译执行；
- 计算器应用：底层计算逻辑（如手机计算器、编程计算器）；
- 表达式求值引擎：如规则引擎、公式编辑器中的表达式解析。
### 总结
- 后缀表达式 = 操作数在前，运算符在后，无括号、无优先级依赖；
- 计算核心：栈（操作数压栈，运算符弹栈计算）；
- 转换核心：栈（存储运算符）+ 输出队列（存储结果），按优先级处理运算符；
- 核心价值：让计算机能简单、高效地处理数学表达式
# 类定义
1、`private class AAA {}`    错误，类不能私有
2、`abstract final class AAA {} `   错误，abstract&final只能用一个

# 反序列化
### 反序列化（Deserialization）详解

反序列化是 **序列化（Serialization）的逆过程**：将之前序列化生成的「字节流」（存储在文件、网络传输数据、内存缓冲区等）恢复为对应的 Java 对象，核心用于恢复对象的状态（字段值、引用关系等），是 Java 实现对象持久化、跨进程 / 跨网络传输对象的核心机制。
#### 一、反序列化的核心前提
要成功反序列化一个对象，必须满足以下条件：
1. 目标类必须实现 `java.io.Serializable` 接口（标记接口，无任何方法，仅表示 “该类支持序列化 / 反序列化”），或 `java.io.Externalizable` 接口（自定义序列化 / 反序列化逻辑）；
2. 目标类的全限定类名必须与序列化时一致（包名 + 类名不能改）；
3. 显式声明 `serialVersionUID`（推荐），否则类结构微小改动（如增减字段）会导致反序列化抛出 `InvalidClassException`；
4. 反序列化的字节流必须是合法的、未被篡改的（否则抛 `StreamCorruptedException` 等异常）。
#### 二、Java 反序列化核心 API
反序列化的核心工具是 `java.io.ObjectInputStream`，其核心方法 `readObject()` 用于读取字节流并还原为对象，常用关联类：
- `ObjectInputStream`：核心反序列化流，读取字节流并解析为对象；
- `FileInputStream`/`ByteArrayInputStream`：字节流来源（文件、内存字节数组等）；
- `ObjectOutputStream`：序列化的核心流（对比理解）。
#### 三、反序列化基础示例（结合序列化）
先序列化一个 `User` 对象到文件，再通过反序列化恢复该对象：
java
运行
```java
import java.io.*;

// 必须实现 Serializable 接口
class User implements Serializable {
    // 显式声明 serialVersionUID，避免类结构变动导致反序列化失败
    private static final long serialVersionUID = 1L;
    
    private String username;
    private transient String password; // 敏感字段，序列化时会被排除
    private int age;

    // 自定义反序列化逻辑（可选）：手动恢复 transient 字段
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject(); // 先恢复非 transient 字段（username、age）
        // 手动恢复 password（比如解密，此处简化为固定值）
        this.password = "default_pwd";
    }

    // 构造方法、getter/setter、toString 省略
    public User(String username, String password, int age) {
        this.username = username;
        this.password = password;
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{username='" + username + "', password='" + password + "', age=" + age + "}";
    }
}

public class DeserializationDemo {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        // ========== 第一步：序列化（生成字节流） ==========
        User user = new User("zhangsan", "123456", 20);
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("user.dat"));
        oos.writeObject(user);
        oos.close();

        // ========== 第二步：反序列化（恢复对象） ==========
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("user.dat"));
        // 读取字节流并还原为对象，需强转类型
        User deserializedUser = (User) ois.readObject();
        ois.close();

        // 输出结果：
        // username/age 被恢复，transient 的 password 被自定义逻辑设为 "default_pwd"
        System.out.println(deserializedUser); 
        // User{username='zhangsan', password='default_pwd', age=20}
    }
}
```
#### 四、反序列化的核心特性
##### 1. 构造方法不执行（Serializable 接口）
反序列化时，JVM 直接通过字节流重建对象，**不会调用类的任何构造方法**（包括无参构造）—— 这是与 `new` 创建对象的核心区别。
- 例外：若类实现 `Externalizable` 接口，反序列化时会先调用无参构造方法，再执行 `readExternal()` 恢复字段。
##### 2. transient 字段的处理
- 默认规则：`transient` 修饰的字段在序列化时未被保存，反序列化时会被还原为「默认值」（基本类型为 0/false，引用类型为 null）；
- 自定义规则：若重写 `readObject()` 方法，可手动恢复 `transient` 字段（如示例中给 password 赋值）。
##### 3. serialVersionUID 的关键作用
`serialVersionUID` 是类的 “序列化版本号”，用于验证序列化 / 反序列化的类结构是否一致：
- 序列化时，JVM 会将类的 `serialVersionUID` 写入字节流；
- 反序列化时，JVM 会对比字节流中的 `serialVersionUID` 与当前类的 `serialVersionUID`：
    - 一致：正常反序列化；
    - 不一致：抛出 `InvalidClassException`。
- 最佳实践：**所有可序列化类都显式声明 `serialVersionUID`**（如 `private static final long serialVersionUID = 1L;`），避免类结构微小改动（如加一个字段）导致反序列化失败。
##### 4. 静态字段不参与反序列化
静态字段属于 “类” 而非 “对象”，反序列化时不会恢复静态字段的值，而是直接取当前类的静态字段值（序列化时的静态值会被忽略）。
#### 五、反序列化的常见问题与解决方案
##### 1. 版本兼容问题
- 现象：类结构修改（如增减字段）后，反序列化旧字节流抛出 `InvalidClassException`；
- 解决方案：显式声明 `serialVersionUID`，且仅在类结构 “完全不兼容” 时修改版本号。
##### 2. 安全风险（核心坑点）
- 风险：反序列化不可信的字节流（如网络传输的恶意数据），可能触发恶意代码执行（Java 反序列化漏洞）；
- 解决方案：
    - 避免反序列化来源不明的字节流；
    - 使用安全的序列化框架（如 Jackson、Gson、Protobuf）替代 Java 原生序列化；
    - 对敏感类添加反序列化校验（如在 `readObject()` 中检查数据合法性）。
##### 3. 不可序列化的字段
- 现象：类中包含 `Thread`、`InputStream`、`Socket` 等不可序列化的字段，序列化时抛 `NotSerializableException`；
- 解决方案：给这些字段加 `transient` 修饰，反序列化时通过 `readObject()` 重新创建（如重新初始化线程 / 流）。
##### 4. 引用对象的反序列化
若对象包含其他可序列化对象的引用，反序列化时会递归恢复所有引用对象（保证对象图的完整性）。
#### 六、Externalizable vs Serializable（反序列化差异）

| 特性   | Serializable（默认序列化）  | Externalizable（自定义序列化）         |
| ---- | -------------------- | ------------------------------ |
| 构造方法 | 不执行任何构造方法            | 必须执行无参构造方法                     |
| 字段恢复 | 自动恢复所有非 transient 字段 | 必须在 `readExternal()` 中手动恢复所有字段 |
| 灵活性  | 低（默认规则）              | 高（完全自定义）                       |
| 性能   | 中等                   | 更高（可按需恢复字段）                    |
#### 七、反序列化的最佳实践
1. 显式声明 `serialVersionUID`，避免版本兼容问题；
2. 敏感字段（密码、令牌）用 `transient` 修饰，且通过 `readObject()` 自定义恢复逻辑（如加密后恢复）；
3. 避免反序列化不可信数据，防止安全漏洞；
4. 优先使用跨语言、轻量级的序列化方式（如 JSON/Protobuf），替代 Java 原生序列化（仅适用于 Java 进程间）；
5. 重写 `readObject()` 时，先调用 `in.defaultReadObject()` 恢复默认字段，再自定义扩展逻辑。
#### 总结
反序列化是 Java 恢复对象状态的核心机制，核心要点：
1. 前提：类实现 `Serializable`/`Externalizable`，且版本号一致；
2. 核心 API：`ObjectInputStream.readObject()`；
3. 关键规则：transient 字段默认恢复为默认值、构造方法不执行、静态字段不参与；
4. 避坑：显式声明 serialVersionUID、防范反序列化安全风险、处理不可序列化字段。

# 二叉树的前序、中序、后序遍历
## 一、[二叉树遍历](https://so.csdn.net/so/search?q=%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86&spm=1001.2101.3001.7020)的核心概念
首先明确三种遍历的**核心差异**：仅在于 “[根节点](https://so.csdn.net/so/search?q=%E6%A0%B9%E8%8A%82%E7%82%B9&spm=1001.2101.3001.7020)的访问时机” 不同，而左子树和右子树的遍历顺序始终是 “先左后右”（这是二叉树遍历的默认规则，除非特殊需求如 “右优先遍历”）。具体定义如下：

| 遍历类型 | 访问顺序            | 核心特征                                               | 适用场景                      |
| ---- | --------------- | -------------------------------------------------- | ------------------------- |
| 前序遍历 | 根节点 → 左子树 → 右子树 | 根节点 “最先访问”，适合需要 “先处理根节点” 的场景（如复制二叉树、获取树的前缀序列）      | 二叉树的序列化、快速获取根节点及左 / 右子树结构 |
| 中序遍历 | 左子树 → 根节点 → 右子树 | 根节点 “中间访问”，对**二叉搜索树（BST）** 而言，中序遍历结果是 “升序序列”       | BST 的排序、查找指定值的前驱 / 后继节点   |
| 后序遍历 | 左子树 → 右子树 → 根节点 | 根节点 “最后访问”，适合需要 “先处理子节点，再处理根节点” 的场景（如计算节点高度、删除二叉树） | 二叉树的销毁、计算节点的子树和           |
#卡片链接
<div>
  <a href="https://blog.csdn.net/m0_74776907/article/details/151968922" target="_blank" style="
      display: inline-flex; 
      align-items: center;
      width: 300px; 
      border: 1px solid #eee; 
      padding: 10px; 
      text-decoration: none; 
      color: #333; 
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      margin: 5px 0;
    ">
      <img src="https://bkimg.cdn.bcebos.com/pic/dbb44aed2e738bd4eea32ffaad8b87d6267ff97f?x-bce-process=image/format,f_auto/quality,Q_70/resize,m_lfit,limit_1,w_536" style="
        width: auto; 
        height: 36px; 
        max-height: 36px; 
        max-width: 72px; 
        object-fit: contain;
      ">
      <p style="
        margin: 0 0 0 8px; 
        font-weight: 500;
        flex: 1;
      ">二叉树的前序、中序、后序遍历_二叉树的前中后序遍历</p>
</a>
</div>


# 防范xss攻击
对输出进行html编码

# 内存泄漏和脏数据的区别
##  内存泄漏（Memory Leak）
**核心逻辑**：GC Roots 到无用对象的引用链未断开，导致对象无法被回收，内存被 “无效占用”。
### 典型示例（Java 场景）：
- **静态集合持有对象引用**：`static List<User> list = new ArrayList<>();` 向集合添加大量 User 对象后，即使业务不再需要这些对象，静态集合的引用会让它们永远无法被 GC，内存持续占用；
- **未关闭的资源**：数据库连接、Socket 连接、文件流（InputStream/OutputStream）未调用 `close()`，底层资源句柄未释放，导致内存泄漏；
- **匿名内部类 / 闭包持有外部类引用**：非静态内部类隐式持有外部类引用，若内部类对象生命周期更长（如线程池中的任务），会导致外部类对象无法回收；
- **缓存未设置过期策略**：本地缓存（如 HashMap 实现）无限添加数据，未做淘汰（LRU/TTL），导致内存占用持续上涨。
### 表现特征：
- 程序运行时间越长，内存占用越高（堆 / 非堆内存曲线持续上升）；
- 最终可能触发 `OutOfMemoryError`（OOM），程序崩溃；
- 不影响数据本身的正确性（数据是对的，只是内存被浪费）。
## 脏数据（Dirty Data）
**核心逻辑**：数据在产生、传输、存储过程中出现 “不完整、不一致、不符合规则” 的情况，违背业务预期。
### 典型示例（Java 业务场景）：
- **事务未提交 / 回滚**：转账场景中，A 账户扣钱后程序异常，B 账户未加钱，事务未回滚，导致 A 账户余额减少（脏数据）；
- **并发更新未加锁**：多线程同时更新用户余额，线程 1 读取余额为 100，线程 2 也读取 100，线程 1 扣 10 后写入 90，线程 2 加 10 后写入 110，最终余额 110（正确应为 100）；
- **数据写入一半**：批量插入 100 条数据时，程序崩溃导致仅插入 50 条，这 50 条未被回滚的 “半截数据” 就是脏数据；
- **非法值写入**：年龄字段写入负数、手机号写入 10 位数字、订单状态同时为 “已支付” 和 “已取消”；
- **缓存与数据库不一致**：更新数据库后缓存未刷新，读取缓存得到旧数据（也称为 “脏读”）。
### 表现特征：
- 数据值不符合业务规则（如负数年龄、重复订单号）；
- 数据之间逻辑矛盾（如订单金额与商品总价不符）；
- 不影响内存使用（内存可能正常），但会导致业务逻辑错误。

## 核心维度对比表

|对比维度|内存泄漏|脏数据|
|---|---|---|
|所属层面|运行时资源管理（内存）|数据存储 / 业务逻辑（数据）|
|产生原因|引用未释放、资源未关闭、缓存无淘汰等|事务异常、并发未控制、输入校验缺失、程序逻辑错误等|
|表现形式|内存占用持续升高，OOM 风险|数据值错误、逻辑不一致、数据不完整|
|影响范围|程序自身性能 / 可用性（如卡顿、崩溃）|业务数据准确性（如对账错误、用户投诉）|
|检测方式|内存分析工具（MAT/JProfiler）、GC 日志分析|数据校验规则、业务监控、对账脚本、数据库约束（主键 / 外键）|
|修复方向|释放无用引用、关闭资源、设置缓存淘汰、优化引用链|完善事务控制、加并发锁、增加数据校验、修复业务逻辑|
|是否可自动恢复|否（需重启程序或手动释放）|否（需手动修正数据或回滚操作）|
