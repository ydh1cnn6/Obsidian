---
title: 深度优先和广度优先
tags:
  - 笔记
  - 未命名
  - 深度优先和广度优先
author: BigSea
email: 2834637197@qq.com
封面: ""
createDate: 2025-12-16 15:59:21
updateDate: 2025-12-16 17:26:30
week: 第51周｜星期二
Country: China
City: NanJing
Weather: ☀️
uvIndex(1-15): 1
Temperature(℃): 17
CurrentWeatherTime: 3:00 PM
GetWeatherTime: 2025-12-16 16:27:44
Feels Like(℃): 17
Pressure(hPa): 1020
Humidity(%): 22
WindSpeed: 2
WindSpeedDesc: 轻风
TempRange(℃): 7-17
SunHour: 10.4h
Sunrise: 06:59 AM
Sunset: 05:02 PM
---
深度优先搜索（DFS, Depth-First Search）和广度优先搜索（BFS, Breadth-First Search）是两种最基础、最核心的**图 / 树的遍历算法**，本质是 “遍历顺序的优先级不同”：DFS 追求 “先深后广”（一条路走到头再回头），BFS 追求 “先广后深”（逐层遍历，先扫完当前层再下一层）。
# 一、核心差异（一张表看懂）
| 维度          | 深度优先搜索（DFS）                            | 广度优先搜索（BFS）                        |
| ----------- | -------------------------------------- | ---------------------------------- |
| 遍历策略        | 优先向 “深度” 延伸，沿一条路径遍历到底，回溯后再走其他分支        | 优先向 “广度” 延伸，先遍历当前层所有节点，再遍历下一层      |
| 核心数据结构      | 栈（Stack）/ 递归（隐式栈）                      | 队列（Queue）                          |
| 空间复杂度       | 取决于递归深度 / 栈深度（最坏 O (h)，h 为树高 / 图的最大深度） | 取决于最宽层的节点数（最坏 O (n)，n 为总节点数）       |
| 适用场景        | 路径查找、拓扑排序、回溯问题（排列 / 组合 / 子集）、连通性检测     | 最短路径（无权图）、层序遍历、广度遍历（社交好友推荐）、最小步数问题 |
| 遍历顺序示例（二叉树） | 根 → 左子树到底 → 回溯 → 右子树（如前序 / 中序 / 后序）    | 根 → 第一层（根）→ 第二层（左右子节点）→ 第三层（孙子节点）  |
| 能否找无权最短路径   | 不能（可能绕远路）                              | 能（逐层遍历，首次到达即为最短）                   |
## 时间复杂度和空间复杂度
| 算法        | 时间复杂度（图） | 时间复杂度（树） |
| --------- | -------- | -------- |
| 深度优先（DFS） | O(V+E)   | O(V)     |
| 广度优先（BFS） | O(V+E)   | O(V)     |

| 算法     | 空间消耗来源  | 最坏空间复杂度 | 典型场景的空间消耗            |
| ------ | ------- | ------- | -------------------- |
| 递归 DFS | 系统递归调用栈 | O(V)    | 平衡树：O(logV)；链式树：O(V) |
| 迭代 DFS | 显式栈     | O(V)    | 与递归 DFS 一致           |
| BFS    | 队列      | O(V)    | 平衡树：O(V/2)；链式树：O(1)  |
# 二、深度优先搜索（DFS）
## 1\. 核心思想
“不撞南墙不回头”：从起始节点出发，选择一个分支一直遍历到**无法继续**（无未访问子节点），再回溯到上一个节点，选择未遍历的分支继续，直到所有节点都被访问。
## 2\. 实现方式
- **递归实现**（最常用，代码简洁，隐式利用 JVM 栈）；
- **非递归实现**（显式用栈，避免递归深度过大导致栈溢出）。
## 3\. 示例：二叉树的 DFS（前序遍历）
java
运行
```
// 二叉树节点定义
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}
// 1. 递归实现 DFS（前序：根 → 左 → 右）
public void dfsRecursive(TreeNode root) {
    if (root == null) return;
    // 1. 访问当前节点
    System.out.print(root.val + " ");
    // 2. 递归遍历左子树（深度优先）
    dfsRecursive(root.left);
    // 3. 递归遍历右子树（回溯后）
    dfsRecursive(root.right);
}
// 2. 非递归实现 DFS（显式栈）
public void dfsStack(TreeNode root) {
    if (root == null) return;
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        // 访问当前节点
        System.out.print(node.val + " ");
        // 栈是“后进先出”，先压右子树，再压左子树（保证左子树先遍历）
        if (node.right != null) stack.push(node.right);
        if (node.left != null) stack.push(node.left);
    }
}
```
## 4\. 核心特点
- 优点：空间复杂度低（仅需存储当前路径），代码简洁（递归）；
- 缺点：递归深度过大时易触发 `StackOverflowError`（需改用非递归），无法直接找无权图的最短路径。
# 三、广度优先搜索（BFS）
## 1\. 核心思想
“地毯式轰炸”：从起始节点出发，先遍历**当前层的所有节点**，再依次遍历下一层的所有节点，直到所有节点都被访问。
## 2\. 实现方式
**必须用队列**（先进先出）：先将起始节点入队，出队时访问该节点，并将其所有未访问的邻接节点入队，循环直到队列为空。
## 3\. 示例：二叉树的 BFS（层序遍历）
java
运行
```
// BFS 层序遍历二叉树（按层输出）
public void bfsQueue(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        // 记录当前层的节点数（实现按层输出）
        int levelSize = queue.size();
        for (int i = 0; i < levelSize; i++) {
            TreeNode node = queue.poll();
            // 访问当前节点
            System.out.print(node.val + " ");
            // 左子节点入队（下一层）
            if (node.left != null) queue.offer(node.left);
            // 右子节点入队（下一层）
            if (node.right != null) queue.offer(node.right);
        }
        System.out.println(); // 每层结束换行
    }
}
```
## 4\. 核心特点
- 优点：能找无权图的最短路径（首次到达目标节点时的路径即为最短），遍历顺序更 “均匀”；
- 缺点：空间复杂度高（需存储当前层所有节点），无法直接实现回溯类问题。
# 四、经典应用场景对比
| 场景                 | 选 DFS 还是 BFS？ | 原因                                   |
| ------------------ | ------------- | ------------------------------------ |
| 二叉树的前 / 中 / 后序遍历   | DFS           | 天然契合 “深度优先” 的遍历逻辑                    |
| 二叉树的层序遍历           | BFS           | 天然契合 “逐层遍历” 的需求                      |
| 无权图的最短路径（如迷宫最短步数）  | BFS           | 逐层遍历，首次到达目标节点的路径即为最短                 |
| 排列 / 组合 / 子集（回溯问题） | DFS           | 需深度遍历一条路径（如选第一个元素→第二个→…），回溯后再试其他分支   |
| 拓扑排序（如依赖任务执行）      | DFS/BFS 均可    | DFS 基于 “后序遍历”，BFS 基于 “入度统计”（Kahn 算法） |
| 检测图的环（如判断有向图是否有环）  | DFS 更易实现      | 递归时记录 “访问中” 的节点，遇到则有环                |
| 社交网络找 “一度 / 二度好友”  | BFS           | 逐层遍历，一度好友（第一层）、二度好友（第二层），天然契合        |
# 五、实战示例：迷宫最短路径（BFS 核心场景）
假设有一个二维数组表示迷宫（0 = 可走，1 = 墙），求从 (0,0) 到 (m-1,n-1) 的最短步数（仅上下左右移动）：
java
运行
```
public int minStepInMaze(int[][] maze) {
    if (maze == null || maze[0][0] == 1) return -1; // 起点是墙，无解
    int m = maze.length, n = maze[0].length;
    int[][] dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}}; // 上下左右
    Queue<int[]> queue = new LinkedList<>();
    queue.offer(new int[]{0, 0});
    maze[0][0] = 1; // 标记已访问（避免重复）
    int step = 0;
    
    while (!queue.isEmpty()) {
        int levelSize = queue.size();
        for (int i = 0; i < levelSize; i++) {
            int[] curr = queue.poll();
            int x = curr[0], y = curr[1];
            if (x == m-1 && y == n-1) return step; // 到达终点，返回步数
            
            // 遍历四个方向
            for (int[] dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx >= 0 && nx < m && ny >=0 && ny < n && maze[nx][ny] == 0) {
                    queue.offer(new int[]{nx, ny});
                    maze[nx][ny] = 1; // 标记已访问
                }
            }
        }
        step++; // 每层遍历完，步数+1
    }
    return -1; // 无解
}
```
# 六、总结
| 特性 | DFS | BFS |
| --- | --- | --- |
| 遍历逻辑 | 先深后广，回溯探索 | 先广后深，逐层扫描 |
| 核心容器 | 栈 / 递归 | 队列 |
| 核心优势 | 回溯、路径探索、省空间 | 最短路径、层序遍历 |
| 核心劣势 | 无最短路径、易栈溢出 | 空间复杂度高 |
**记忆口诀**：
- 要 “找路径、回溯试错”→ 选 DFS（比如排列组合、迷宫所有路径）；
- 要 “找最短、逐层遍历”→ 选 BFS（比如无权图最短路径、层序输出）。 

