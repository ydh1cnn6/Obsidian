# JVM模型

![image-20230819094210868](https://my-picture-aa.oss-cn-nanjing.aliyuncs.com/img/202308190942168.png)

补充：**本地接口**和**本地方法栈**进行交互

## 运行时方法区

堆:存放对象，所有线程公有
		栈:线程私有，每一个方法执行的时候都公有自己的栈空间。局部变量，操作數，引用，		方法出口信息等
		方法区:公有，被虚拟机加载的类信息，静态变量，常量池(jdk1.8后移到堆) ，即时编译器编译后的代码
		程序计数器:线程私有，存储执行的方法代码的行号，用来控制跳转，循环，分支，选择等
		本地方法栈:执行本地方法

## 类加载过程

[类加载过程]([一文读懂Java类加载全过程，面试必备！ (dtmao.cc)](http://www.dtmao.cc/NodeJs/78494.html))

双亲委派机制的好处有什么:
			1:防止类的重复加载
			2:沙箱安全机制，防止篡改Java的核心API I
			ClassLoader加载的原则:
		   双亲委派模型
					可见性:子类加载器是访问父类加载器加载的类，但是父类加载器是不能访问子类加载器加载的类
					唯一:同一个命名空间，- 一个类只会被加载一-次

## 类加载器

# 垃圾回收

## 垃圾判断

引用计数法:问题，无法处理循环引用

根可达:从栈变量，静态变量，常量池。JNI指针(本地方法)等作为root.可以解决循环依赖问题

## 回收算法

分代回收:不同的代里面使用的回收算法是不同的

标记清除:

​		特点：垃圾区域直接回收

​		优缺点:``优``：算法简单;``缺``：内存碎片化

拷贝：

​		特点：将内存分成两份，一般存储数据，另一半留着拷贝用

​		优点：效率比较高，没有碎片，

​		缺点：内存利用率低

标记压缩：

​		特点:一边标记一边整理
​				优点I没有碎片，空间利用率也高
​				缺点:算法比较复杂，效率降低

## 分代模型

新生代+老年代+永久代(1.7)/元空间

永久代(1.7)/元空间

​		逻辑名称：方法区

​		存放：静态变量、1.7前的常量、类信息、即时编译代码

​		大小：1.7之前要设置大小，1.8不用了(受限于物理内存)

调优：基本无视这一块

常说的内存：

-Xmx和-Xms设置为一样大，目的是避免伸缩（xmx默认1/4物理内存）

![image-20230819160721365](https://my-picture-aa.oss-cn-nanjing.aliyuncs.com/img/202308191607517.png)



parallel scavenge

# java对象的引用类型

## 强引用

A a = new A();

垃圾回收器宁愿抛出00M，也不会回收强引用指向的对象

## 弱引用

当内存足够的时候，不公被回收，如果内存不足，则公被回收

## 软引用

gc调用则回收

## 虚引用

虚引用也称为幽灵或者幻影应用
		特点:
				对象上是否有虚引用，不会对对象的生存造成影响
				必须和引用队列- -起使用，用于垃圾回收的跟踪





​				