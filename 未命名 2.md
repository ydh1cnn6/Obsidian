---
title: 未命名 2
updateDate: 2025-11-26 13:55:31
---

```dataviewjs
// 1. 动态引入所需库
const libraries = [
    { src: 'https://cdn.jsdelivr.net/npm/marked/marked.min.js', name: 'marked' },
    { src: 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js', name: 'DOMPurify' },
    { src: 'https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js', name: 'Sortable' },
    { src: 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js', name: 'hljs' }
];

const loadedLibraries = new Set();
const loadLibrary = (lib) => {
    return new Promise((resolve, reject) => {
        if (loadedLibraries.has(lib.name) && window[lib.name]) {
            console.log(`[LIB] ${lib.name} is already loaded.`);
            return resolve();
        }
        console.log(`[LIB] Loading ${lib.name}...`);
        const script = document.createElement('script');
        script.src = lib.src;
        script.onload = () => {
            loadedLibraries.add(lib.name);
            console.log(`[LIB] ${lib.name} loaded successfully.`);
            resolve();
        };
        script.onerror = () => {
            console.error(`[LIB] Failed to load ${lib.name}`);
            reject(new Error(`Failed to load ${lib.name}`));
        };
        document.head.appendChild(script);
    });
};

// --- 内嵌样式表 ---
const customStyle = document.createElement('style');
customStyle.textContent = `
  /* highlight.js 主题 */
  .hljs { display: block; overflow-x: auto; padding: 0.5em; color: #c9d1d9; background: #0d1117; }
  .hljs-doctag, .hljs-keyword, .hljs-meta .hljs-keyword, .hljs-template-tag, .hljs-template-variable, .hljs-type, .hljs-variable.language_ { color: #ff7300; }
  .hljs-title, .hljs-title.class_, .hljs-title.class_.inherited__, .hljs-title.function_ { color: #3fb950; }
  .hljs-attr, .hljs-attribute, .hljs-literal, .hljs-meta, .hljs-number, .hljs-operator, .hljs-variable, .hljs-selector-attr, .hljs-selector-class, .hljs-selector-id { color: #79c0ff; }
  .hljs-regexp, .hljs-string, .hljs-meta .hljs-string { color: #e3b341; }
  .hljs-built_in, .hljs-symbol { color: #f8d583; }
  .hljs-comment, .hljs-code, .hljs-formula { color: #8b949e; }
  .hljs-name, .hljs-quote, .hljs-selector-pseudo, .hljs-selector-tag { color: #d2a8ff; }
  .hljs-subst { color: #c9d1d9; }
  .hljs-section { color: #1f6feb; font-weight: bold; }
  .hljs-bullet { color: #f2cc60; }
  .hljs-emphasis { color: #c9d1d9; font-style: italic; }
  .hljs-strong { color: #c9d1d9; font-weight: bold; }

  /* Markdown 元素边距重置 */
  .editor-content > h1, .editor-content > h2, .editor-content > h3, .editor-content > h4, .editor-content > h5, .editor-content > h6, .editor-content > p, .editor-content > ul, .editor-content > ol, .editor-content > pre, .editor-content > blockquote, .editor-content > table {
    margin-top: 0 !important; margin-bottom: 0.75em !important;
  }
  .editor-content > ul li, .editor-content > ol li { margin-bottom: 0.3em !important; }
  .editor-content > pre { padding: 0.8em !important; margin-bottom: 1em !important; }

  /* 操作按钮容器 */
  .action-buttons {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }
  
  /* 拖拽手柄样式 */
  .drag-handle {
    cursor: grab;
    color: #6366f1;
    user-select: none;
    font-size: 1.4em;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: background-color 0.2s ease;
  }
  .drag-handle:hover {
    background-color: rgba(99, 102, 241, 0.1);
  }
  .drag-handle:active {
    cursor: grabbing;
    color: #4f46e5;
  }
  
  /* 删除按钮样式 */
  .delete-column-btn {
    background: transparent !important; color: #ef4444 !important; border: none !important; outline: none !important;
    cursor: pointer; font-size: 1.4em; padding: 0; user-select: none;
    width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 50%;
    transition: color 0.2s ease;
  }
  .delete-column-btn:hover { color: #f87171 !important; }
  .delete-column-btn:active { color: #dc2626 !important; }

  /* 正在保存标识样式 */
  #save-indicator {
    position: absolute; top: 10px; right: 20px;
    background-color: rgba(79, 70, 229, 0.8); color: white;
    padding: 4px 12px; border-radius: 20px; font-size: 14px; font-weight: 500;
    opacity: 0; transition: opacity 0.3s ease; pointer-events: none; z-index: 1000;
  }
  #save-indicator.visible { opacity: 1; }

  /* 标题编辑样式 */
  .column-title {
    min-width: 50px; padding: 2px 4px; border-radius: 4px;
    transition: border 0.2s ease; border: 1px solid transparent;
  }
  .column-title:hover { border-color: #e5e7eb; }
  .column-title:focus { outline: none; border: 1px solid #6366f1; background-color: #f9fafb; }
  
  /* 空状态提示 */
  .empty-state {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      color: #9ca3af;
      font-style: italic;
  }

  /* 用于在调整大小时屏蔽页面其他事件 */
  .resizing-body * {
    pointer-events: none !important;
  }
  .resizing-body .resizer,
  .resizing-body .resizer * {
    pointer-events: auto !important;
  }

  /* 编辑状态样式 - 增强可见性 */
  .editor-content.editing {
    background-color: #ffffff !important;
    border: 2px solid #ef4444 !important; /* 使用更醒目的红色边框 */
    border-radius: 4px;
    padding: 8px !important;
    pointer-events: auto !important; /* 确保可以交互 */
    z-index: 10 !important; /* 确保在最上层 */
  }
`;
document.head.appendChild(customStyle);

// 2. 全局状态和 DOM 元素
let columns = [];
let sortableInstance = null;
const container = dv.container;
let columnContainer, addColumnBtn, saveIndicator;
let isResizing = false; 
let startX = 0, initialLeftWidth = 0, initialRightWidth = 0;
let leftColEl = null, rightColEl = null;

// 存储全局事件监听器，便于后续统一清理
const globalEventListeners = new Map();

// 3. 数据持久化
const getNoteUniqueId = () => dv.current().file.path.replace(/\//g, '_');
const showSaveIndicator = () => saveIndicator?.classList.add('visible');
const hideSaveIndicator = () => saveIndicator?.classList.remove('visible');

const saveColumnsData = () => {
    console.log('[DATA] saveColumnsData triggered.');
    showSaveIndicator();
    requestAnimationFrame(() => {
        try {
            // 仅同步当前存在的分栏
            columns = columns.filter(col => document.body.contains(col));
            const data = columns.map((col, index) => ({
                title: col.querySelector('.column-title').innerText.trim() || `分栏 ${index + 1}`,
                content: col.querySelector('.editor-content').dataset.markdown || '',
                width: col.style.flexBasis || `${100 / columns.length}%`
            }));
            localStorage.setItem(`multiColumnData_${getNoteUniqueId()}`, JSON.stringify(data));
            console.log(`[DATA] Saved ${data.length} columns to localStorage.`);
        } catch (e) {
            console.error('[DATA] Failed to save columns data:', e);
        } finally {
            setTimeout(hideSaveIndicator, 300);
        }
    });
};

const loadColumnsData = () => {
    try {
        const data = localStorage.getItem(`multiColumnData_${getNoteUniqueId()}`);
        console.log(`[DATA] Loaded data from localStorage:`, data ? JSON.parse(data) : 'No data');
        return data ? JSON.parse(data) : null;
    } catch (e) {
        console.error('[DATA] Failed to load columns data:', e);
        localStorage.removeItem(`multiColumnData_${getNoteUniqueId()}`);
        return null;
    }
};

// 优化：只同步当前存在的、处于编辑状态的分栏
const syncEditingContent = () => {
  console.log('[EDIT] syncEditingContent triggered.');
  // 过滤掉已被移除的分栏
  columns = columns.filter(col => document.body.contains(col));
  console.log(`[EDIT] Columns array filtered to ${columns.length} items.`);
  
  columns.forEach(col => {
    const editor = col.querySelector('.editor-content');
    if (editor && editor.classList.contains('editing')) {
      console.log(`[EDIT] Syncing content for column with title: "${col.querySelector('.column-title').innerText}"`);
      const cleanedContent = editor.innerText.replace(/\n{3,}/g, '\n\n');
      editor.dataset.markdown = cleanedContent;
      editor.classList.remove('editing');
      editor.innerHTML = renderMarkdown(cleanedContent);
    }
  });
};

const renderMarkdown = (markdownText = '') => {
  markdownText = String(markdownText || '');
  if (!window.marked || !window.DOMPurify) {
    console.warn('[RENDER] Dependencies (marked/DOMPurify) not ready.');
    return markdownText;
  }
  const renderer = new window.marked.Renderer();
  renderer.code = function(code, language) {
    code = String(code || '');
    if (!window.hljs) return `<pre><code>${window.DOMPurify.sanitize(code)}</code></pre>`;
    try {
      const result = language && window.hljs.getLanguage(language)
        ? window.hljs.highlight(code, { language })
        : window.hljs.highlightAuto(code);
      return `<pre><code class="hljs language-${result.language}">${result.value}</code></pre>`;
    } catch (err) {
        console.error('[RENDER] Code highlight failed:', err);
        return `<pre><code class="hljs">${window.DOMPurify.sanitize(code)}</code></pre>`;
    }
  };
  return window.DOMPurify.sanitize(
    window.marked.parse(markdownText, { renderer, gfm: true, breaks: true, smartLists: true, smartypants: false })
  );
};

// --- 分栏操作 ---
const createResizer = () => {
    const resizer = document.createElement('div');
    resizer.className = 'resizer';
    resizer.style.cssText = 'width: 12px; background: rgba(99, 102, 241, 0.1); position: relative; touch-action: none; cursor: col-resize; flex-shrink: 0; display: flex; align-items: center; justify-content: center; z-index: 10;';
    const innerBar = document.createElement('div');
    innerBar.style.cssText = 'width: 4px; height: 80px; background: #6366f1; border-radius: 2px;';
    resizer.appendChild(innerBar);
    return resizer;
};

const startResize = (e, resizer) => {
    // 移除之前可能残留的事件监听器
    document.removeEventListener('mousemove', doResize);
    document.removeEventListener('mouseup', endResize);
    document.removeEventListener('mouseleave', endResize);

    const resizerIndex = Array.from(columnContainer.children).indexOf(resizer);
    if (resizerIndex === -1) return;
    leftColEl = columnContainer.children[resizerIndex - 1];
    rightColEl = columnContainer.children[resizerIndex + 1];
    if (!leftColEl || !rightColEl || !leftColEl.classList.contains('column') || !rightColEl.classList.contains('column')) {
        console.error('无法找到相邻的分栏');
        return;
    }

    isResizing = true;
    startX = e.clientX;
    initialLeftWidth = parseFloat(leftColEl.style.flexBasis || (100 / columns.length));
    initialRightWidth = parseFloat(rightColEl.style.flexBasis || (100 / columns.length));
    
    document.body.classList.add('resizing-body');
    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';

    document.addEventListener('mousemove', doResize);
    document.addEventListener('mouseup', endResize);
    document.addEventListener('mouseleave', endResize);

    e.preventDefault();
    e.stopPropagation();
};

const doResize = (e) => {
    if (!isResizing) return;
    const containerRect = columnContainer.getBoundingClientRect();
    const mouseDelta = e.clientX - startX;
    const percentDelta = (mouseDelta / containerRect.width) * 100;
    
    const newLeftWidth = initialLeftWidth + percentDelta;
    const newRightWidth = initialRightWidth - percentDelta;
    const minWidth = 10;

    if (newLeftWidth >= minWidth && newRightWidth >= minWidth) {
        leftColEl.style.flexBasis = `${newLeftWidth}%`;
        rightColEl.style.flexBasis = `${newRightWidth}%`;
    }
    
    e.preventDefault();
    e.stopPropagation();
};

const endResize = () => {
    if (isResizing) {
        isResizing = false;
        // 确保所有事件监听器都被移除
        document.removeEventListener('mousemove', doResize);
        document.removeEventListener('mouseup', endResize);
        document.removeEventListener('mouseleave', endResize);

        document.body.classList.remove('resizing-body');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        
        startX = initialLeftWidth = initialRightWidth = 0;
        leftColEl = rightColEl = null;
        
        saveColumnsData();
    }
};

const bindResizeEvents = (resizer) => {
    const mouseDownHandler = (e) => startResize(e, resizer);
    resizer.addEventListener('mousedown', mouseDownHandler);
    return () => {
        resizer.removeEventListener('mousedown', mouseDownHandler);
        if (isResizing && leftColEl && rightColEl) {
            endResize();
        }
    };
};

const rebuildResizers = () => {
    console.log('[LAYOUT] rebuildResizers triggered.');
    columnContainer.querySelectorAll('.resizer').forEach(resizer => {
        if (resizer.unbind) {
            resizer.unbind();
            resizer.unbind = null;
        }
        resizer.remove();
    });
    if (columns.length < 2) {
        console.log('[LAYOUT] Not enough columns to need resizers.');
        return;
    }
    columns.forEach((col, index) => {
        if (index < columns.length - 1) {
            const resizer = createResizer();
            col.after(resizer);
            resizer.unbind = bindResizeEvents(resizer);
        }
        col.style.borderRight = index < columns.length - 1 ? '1px solid #e2e8f0' : 'none';
    });
    console.log(`[LAYOUT] Rebuilt resizers between ${columns.length} columns.`);
};

const createColumnElement = (title = '', content = '', width = '') => {
  title = String(title || '');
  content = String(content || '');
  console.log(`[UI] Creating new column: Title="${title}", Width="${width}"`);
  const newColumn = document.createElement('div');
  newColumn.className = 'column';
  newColumn.style.cssText = `flex: 1 1 ${width}; padding: 1px; background: #f9fafb; box-sizing: border-box; overflow: auto; display: flex; flex-direction: column;`;
  
  newColumn.innerHTML = `
    <div style="display: flex; justify-content: space-between; align-items: center; font-size: 18px; font-weight: 600; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #6366f1;">
      <span class="column-title" contenteditable="true" spellcheck="false">${title}</span>
      <div class="action-buttons">
        <span class="drag-handle">☰</span>
        <button class="delete-column-btn">✕</button>
      </div>
    </div>
    <div class="editor-content" style="flex-grow: 1; min-height: 350px; outline: none; font-size: 15px; line-height: 1.6; color: #374151; white-space: pre-wrap; word-break: break-word; padding: 0 5px;" contenteditable="true" data-markdown="${content}">${renderMarkdown(content)}</div>
  `;
  return newColumn;
};

// ========================================================
// ==                  核心逻辑区域                       ==
// ========================================================

const initDragAndDrop = () => {
    if (sortableInstance) {
        sortableInstance.destroy();
        console.log('[DRAG] Sortable instance destroyed.');
        sortableInstance = null;
    }
    if (columns.length <= 1) {
        console.log('[DRAG] Not enough columns to initialize Sortable.');
        return;
    }
    try {
        sortableInstance = new window.Sortable(columnContainer, {
            animation: 150,
            handle: '.drag-handle',
            draggable: '.column',
            ghostClass: 'sortable-ghost',
            onStart: () => {
                syncEditingContent();
                document.body.style.userSelect = 'none';
            },
            onEnd: () => {
                columns = Array.from(columnContainer.querySelectorAll('.column'));
                console.log('[DRAG] Column order changed. New columns array:', columns);
                rebuildResizers();
                saveColumnsData();
                document.body.style.userSelect = '';
            }
        });
        console.log('[DRAG] Sortable initialized successfully.');
    } catch (e) {
        console.error('[DRAG] Failed to initialize Sortable:', e);
        document.body.style.userSelect = '';
    }
};

const addNewColumn = (title = '', content = '', width = '') => {
    console.log('[COLUMN] addNewColumn triggered.');
    syncEditingContent();
    if (columns.length === 0) {
        columnContainer.innerHTML = '';
    }
    const newColCount = columns.length + 1;
    const newWidthPercent = width || `${100 / newColCount}%`;
    const widthToTakePerExistingCol = columns.length > 0 ? (parseFloat(newWidthPercent) / columns.length) : 0;
    columns.forEach(col => {
        const currentWidth = parseFloat(col.style.flexBasis || (100 / columns.length));
        const newWidth = currentWidth - widthToTakePerExistingCol;
        col.style.flexBasis = `${newWidth}%`;
    });
    
    const effectiveTitle = title ? String(title).trim() : '';
    const defaultTitle = effectiveTitle || `分栏 ${newColCount}`;
    const defaultContent = content ? String(content).trim() : `# 新分栏 ${newColCount}\n\n在这里输入你的内容，支持 **Markdown** 和代码高亮。\n\n点击分栏内容区域开始编辑。`;
    
    const newColumn = createColumnElement(defaultTitle, defaultContent, newWidthPercent);
    columnContainer.appendChild(newColumn);
    columns.push(newColumn);
    
    rebuildResizers();
    initDragAndDrop();
    newColumn.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    saveColumnsData();
    console.log(`[COLUMN] New column added. Total columns: ${columns.length}`);
    return newColumn;
};

// 优化后的 deleteColumn 函数
const deleteColumn = (columnToDelete) => {
    console.log('[COLUMN] deleteColumn triggered.');

    // 关键修复 #1: 在删除前，强制结束所有编辑状态，确保一个干净的初始状态
    syncEditingContent();

    // 关键修复 #2: 主动让删除按钮失焦，防止焦点混乱
    const deleteBtn = columnToDelete.querySelector('.delete-column-btn');
    if (deleteBtn) {
        deleteBtn.blur();
        document.activeElement.blur();
    }

    // 1. 强制结束任何可能的 resize 操作
    endResize();
    
    // 2. 确认提示
    if (columns.length <= 1) {
        if (!confirm('确定要删除最后一个分栏吗？此操作将清除所有本地存储的分栏数据！')) {
            console.log('[COLUMN] Delete cancelled by user (last column).');
            return;
        }
    } else if (!confirm('确定要删除这个分栏吗？内容将永久丢失！')) {
        console.log('[COLUMN] Delete cancelled by user.');
        return;
    }

    const title = columnToDelete.querySelector('.column-title').innerText;
    console.log(`[COLUMN] Deleting column: "${title}"`);
    
    // 3. 从 DOM 和数组中移除分栏
    columnToDelete.remove();
    columns = columns.filter(col => col !== columnToDelete);
    console.log(`[COLUMN] Column removed. Remaining columns: ${columns.length}`);
    
    // 4. 根据剩余分栏数量进行后续处理
    if (columns.length > 0) {
        // 重新分配宽度
        const widthPercent = `${100 / columns.length}%`;
        columns.forEach(col => col.style.flexBasis = widthPercent);
        console.log(`[LAYOUT] Widths redistributed to ${widthPercent} each.`);
        
        // 使用 requestAnimationFrame 确保 DOM 更新完成
        requestAnimationFrame(() => {
            rebuildResizers();
            initDragAndDrop();
            
            // 关键修复 #3: 延迟重新绑定事件，给浏览器时间处理完删除引发的事件（如 blur）
            setTimeout(() => {
                rebindEventDelegation();
                
                // 关键修复 #4: 如果只剩一个分栏，尝试主动聚焦它
                if (columns.length === 1) {
                    setTimeout(() => {
                        const editor = columns[0].querySelector('.editor-content');
                        if (editor) {
                            editor.focus();
                            console.log('[COLUMN] Focused the last remaining column\'s editor.');
                        }
                    }, 100);
                }
            }, 0); // 短暂延迟，将绑定操作放入队列末尾
            
            // 异步保存数据，不阻塞UI
            setTimeout(saveColumnsData, 100);
        });
        
    } else {
        // 如果没有分栏了，清理本地存储并显示空状态
        columnContainer.innerHTML = '<div class="empty-state">没有分栏，请点击上方 "+ 新增分栏" 按钮创建</div>';
        localStorage.removeItem(`multiColumnData_${getNoteUniqueId()}`);
        console.log('[COLUMN] All columns deleted. UI reset.');
    }
};

// 新增：重新绑定事件委托的函数
const rebindEventDelegation = () => {
    console.log('[EVENT] rebindEventDelegation triggered.');
    // 移除现有的事件监听器
    if (columnContainer) {
        columnContainer.removeEventListener('mousedown', handleEditorMouseDown);
        columnContainer.removeEventListener('blur', handleEditorBlur, true);
        columnContainer.removeEventListener('keydown', handleEditorKeydown);
        columnContainer.removeEventListener('click', handleDeleteClick);
        columnContainer.removeEventListener('blur', handleTitleBlur, true);
        columnContainer.removeEventListener('keydown', handleTitleKeydown);
    }

    // 确保所有编辑状态被清除
    document.querySelectorAll('.editor-content.editing').forEach(editor => {
        editor.classList.remove('editing');
    });
    
    // 立即重新绑定事件
    bindEventDelegation();
};

// 新增：专门的事件处理函数
const handleEditorMouseDown = (e) => {
    console.log('[EVENT] handleEditorMouseDown triggered.');
    if (isResizing) {
        console.log('[EVENT] Resizing in progress. Aborting editor click.');
        return;
    }
    const editorContent = e.target.closest('.editor-content');
    if (editorContent && !editorContent.classList.contains('editing')) {
        console.log(`[EVENT] Entering edit mode for editor.`);
        syncEditingContent(); // 确保其他编辑器已同步
        
        const markdownContent = editorContent.dataset.markdown || '';
        editorContent.innerText = markdownContent;
        editorContent.classList.add('editing');
        
        // 使用 setTimeout 确保 focus 在 DOM 更新后执行
        setTimeout(() => {
            editorContent.focus();
            const range = document.createRange();
            range.selectNodeContents(editorContent);
            range.collapse(false);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }, 0);
    }
};

const handleEditorBlur = (e) => {
    console.log('[EVENT] handleEditorBlur triggered.');
    const editorContent = e.target.closest('.editor-content');
    if (editorContent && editorContent.classList.contains('editing')) {
        console.log(`[EVENT] Exiting edit mode for editor.`);
        const cleanedContent = editorContent.innerText.replace(/\n{3,}/g, '\n\n');
        editorContent.dataset.markdown = cleanedContent;
        editorContent.classList.remove('editing');
        editorContent.innerHTML = renderMarkdown(cleanedContent);
        saveColumnsData();
    }
};

const handleEditorKeydown = (e) => {
    const editorContent = e.target.closest('.editor-content');
    if (editorContent && editorContent.classList.contains('editing')) {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            console.log('[EVENT] Ctrl+Enter detected. Blurring editor.');
            e.preventDefault();
            editorContent.blur();
        }
        e.stopPropagation();
    }
};

const handleDeleteClick = (e) => {
    console.log('[EVENT] handleDeleteClick triggered.');
    const deleteBtn = e.target.closest('.delete-column-btn');
    if (deleteBtn) {
        e.preventDefault();
        e.stopPropagation();
        const columnToDelete = deleteBtn.closest('.column');
        if (columnToDelete) {
            deleteColumn(columnToDelete);
        }
    }
};

const handleTitleBlur = (e) => {
    if (e.target.classList.contains('column-title')) {
        console.log('[EVENT] Column title blurred. Saving data.');
        saveColumnsData();
    }
};

const handleTitleKeydown = (e) => {
    if (e.target.classList.contains('column-title') && (e.key === 'Enter' || e.key === 'Escape')) {
        console.log('[EVENT] Enter/Escape pressed in title. Blurring.');
        e.preventDefault();
        e.target.blur();
    }
};

// 新增：专门的事件绑定函数
const bindEventDelegation = () => {
    console.log('[EVENT] bindEventDelegation triggered.');
    if (!columnContainer) return;
    
    // 1. 委托事件：处理 .editor-content 的点击（进入编辑模式）
    columnContainer.addEventListener('mousedown', handleEditorMouseDown);
    // 2. 委托事件：处理 .editor-content 的失去焦点（保存编辑内容）
    columnContainer.addEventListener('blur', handleEditorBlur, true);
    // 3. 委托事件：处理 .editor-content 的键盘事件（Ctrl+Enter）
    columnContainer.addEventListener('keydown', handleEditorKeydown);
    // 4. 委托事件：处理 .delete-column-btn 的点击
    columnContainer.addEventListener('click', handleDeleteClick);
    // 5. 委托事件：处理 .column-title 的失去焦点和键盘事件
    columnContainer.addEventListener('blur', handleTitleBlur, true);
    columnContainer.addEventListener('keydown', handleTitleKeydown);
};

// --- 初始化与销毁 ---
const init = () => {
    console.log('%c[INIT] Initializing Multi-Column Component...', 'font-size: 16px; font-weight: bold; color: #6366f1;');
    
    // 确保容器为空
    container.innerHTML = '';
    
    // 创建主容器结构
    const mainContainer = document.createElement('div');
    mainContainer.style.cssText = 'position: relative; width: 100%; margin: 20px 0; box-sizing: border-box;';
    
    // 创建按钮容器
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = 'position: absolute; top: -20px; left: 10px; display: flex; gap: 10px; z-index: 999;';
    
    // 创建新增分栏按钮
    addColumnBtn = document.createElement('button');
    addColumnBtn.id = 'addColumnBtn';
    addColumnBtn.textContent = '+ 新增分栏';
    addColumnBtn.style.cssText = 'background: #6366f1; color: white; border: none; border-radius: 6px; padding: 6px 12px; cursor: pointer; font-size: 14px;';
    buttonContainer.appendChild(addColumnBtn);
    
    // 创建保存指示器
    saveIndicator = document.createElement('div');
    saveIndicator.id = 'save-indicator';
    saveIndicator.textContent = '正在保存...';
    saveIndicator.style.cssText = 'position: absolute; top: 10px; right: 20px; background-color: rgba(79, 70, 229, 0.8); color: white; padding: 4px 12px; border-radius: 20px; font-size: 14px; font-weight: 500; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; z-index: 1000;';
    
    // 创建分栏容器
    columnContainer = document.createElement('div');
    columnContainer.id = 'columnContainer';
    columnContainer.style.cssText = 'display: flex; width: 100%; border: 3px solid #6366f1; border-radius: 12px; overflow: hidden; height: 450px; box-sizing: border-box;';
    
    // 组装DOM结构
    mainContainer.appendChild(buttonContainer);
    mainContainer.appendChild(saveIndicator);
    mainContainer.appendChild(columnContainer);
    container.appendChild(mainContainer);
    
    // 检查元素是否成功创建
    if (!addColumnBtn || !columnContainer || !saveIndicator) {
        console.error('[INIT] Failed to create essential DOM elements!');
        container.innerHTML = '<div style="color: red; padding: 20px;">组件初始化失败：无法创建必要的界面元素。</div>';
        return;
    }

    // 绑定事件
    bindEventDelegation();

    // 加载保存的分栏数据
    const savedData = loadColumnsData();
    if (savedData && savedData.length > 0) {
        savedData.forEach(data => {
            const newColumn = createColumnElement(data.title, data.content, data.width);
            columnContainer.appendChild(newColumn);
            columns.push(newColumn);
        });
        rebuildResizers();
        console.log(`[INIT] Loaded ${savedData.length} columns from saved data.`);
    } else {
        // 默认创建两个分栏
        addNewColumn('分栏 1', '# 这里是分栏 1 的内容\n\n支持 **Markdown** 语法！\n\n- 列表项 1\n- 列表项 2', '50%');
        addNewColumn('分栏 2', '这里是分栏 2 的内容\n\n点击分栏内容区域开始编辑，点击外部区域或按 Ctrl+Enter 完成编辑。', '50%');
        console.log('[INIT] No saved data. Created default columns.');
    }
    
    initDragAndDrop();
    
    // 绑定新增分栏按钮事件
    addColumnBtn.addEventListener('click', () => addNewColumn());
    
    // 点击空白处同步内容
    const docClickHandler = (e) => {
        if (!e.target.closest('#columnContainer') && columns.length > 0 && !isResizing) {
            syncEditingContent();
        }
    };
    document.addEventListener('click', docClickHandler);
    globalEventListeners.set('document:click', docClickHandler);
    
    console.log('%c[INIT] Initialization complete!', 'font-size: 16px; font-weight: bold; color: #3fb950;');
};

// 简化的 destroy 函数
const destroy = () => {
    console.log('[DESTROY] Destroying Multi-Column Component...');
    // 销毁拖拽实例
    if (sortableInstance) {
        sortableInstance.destroy();
    }
    // 移除全局事件监听
    globalEventListeners.forEach((handler, key) => {
        const [target, event] = key.split(':');
        if (target === 'document') {
            document.removeEventListener(event, handler);
        }
    });
    globalEventListeners.clear();
    // 移除自定义样式
    if (customStyle && customStyle.parentNode) {
        customStyle.parentNode.removeChild(customStyle);
    }
    // 清空容器
    if (container) {
        container.innerHTML = '';
    }
    console.log('[DESTROY] Component destroyed.');
};

// 加载所有库后初始化
Promise.all(libraries.map(loadLibrary))
    .then(init)
    .catch(err => {
        console.error("[INIT] Initialization failed:", err);
        container.innerHTML = `<div style="color: red; padding: 20px;">加载依赖库失败，请检查网络连接或刷新页面。</div>`;
    });

// 在 Obsidian 中，当视图切换时，确保销毁旧的组件实例
module.exports = {
    destroy: destroy
};
```
